{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/tcp3waysynch.png","path":"images/tcp3waysynch.png","modified":0,"renderable":0},{"_id":"source/images/tcpclose1.png","path":"images/tcpclose1.png","modified":0,"renderable":0},{"_id":"source/images/tcpfsm1.png","path":"images/tcpfsm1.png","modified":0,"renderable":0},{"_id":"source/images/tcpopen3way.png","path":"images/tcpopen3way.png","modified":0,"renderable":0},{"_id":"source/images/macro_1.png","path":"images/macro_1.png","modified":0,"renderable":0},{"_id":"source/images/rgb2yuv.png","path":"images/rgb2yuv.png","modified":0,"renderable":0},{"_id":"source/images/timg.jpeg","path":"images/timg.jpeg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"source/images/state_machine.png","path":"images/state_machine.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/tcp_close_state_machine.png","path":"images/tcp_close_state_machine.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/proxy_2.png","path":"images/proxy_2.png","modified":0,"renderable":0},{"_id":"source/images/proxy_3.png","path":"images/proxy_3.png","modified":0,"renderable":0},{"_id":"source/images/proxy_1.png","path":"images/proxy_1.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"a129233461e1f87d655aefc636082eaaf663c119","modified":1571300269682},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1571625736230},{"_id":"themes/next/_config.yml","hash":"d0f79a8f1d33dcffa8b550bfbdc9c6264158dcdb","modified":1571808107574},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1565947710333},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1565947710334},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1565947710334},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1565947710334},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1565947710352},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1571807712932},{"_id":"source/_posts/ARC详解.md","hash":"ce0311b83e2a3a01bcba062bcc2dc3a355b4f7fc","modified":1571111666709},{"_id":"source/_posts/C-中调用OC代码.md","hash":"3308792cfd93721f977fc5fdb34f13d848b53c93","modified":1566278851525},{"_id":"source/_posts/C、CPlusPlus格式化字符串.md","hash":"7563a0101363f54ad674399365c2ef8d5d510ac6","modified":1568095333266},{"_id":"source/_posts/Mac-OpenGL环境搭建.md","hash":"502c5ee0be645928ebc7be4dd477152d160988d3","modified":1566277995677},{"_id":"source/_posts/TCP的三次握手与四次挥手.md","hash":"1d8a113785bd4240fa5049752c887fd0573bd9b2","modified":1567568200645},{"_id":"source/_posts/iOS-RGBA转YV12.md","hash":"c53019e0329d8ed60baf7fdcbbe4decee724fc92","modified":1571306464730},{"_id":"source/_posts/initial-blog.md","hash":"93d605f1edc216e5c92eb0db872e91fd4f16e239","modified":1571807826147},{"_id":"source/_posts/mysql重置密码.md","hash":"87e8365a13759ef6bbe3aed5eb8e39a4c84cbe01","modified":1571112046200},{"_id":"source/_posts/杂记.md","hash":"eed47e5afaac17a4902f5b1c99d9d3a65223afb2","modified":1571807682084},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1566198972583},{"_id":"source/categories/index.md","hash":"086101db89e861a8707f9a79c0db462dc748d7de","modified":1566200741907},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1567501067633},{"_id":"source/images/tcp3waysynch.png","hash":"0e7bee13918ed0d1eb55a887b82c529500468120","modified":1567501012443},{"_id":"source/images/tcpclose1.png","hash":"805ec3ea6d462b4bb451a017292922e634c84fb9","modified":1567501044850},{"_id":"source/images/tcpfsm1.png","hash":"34c92f937d294d778591f86b31e6ae895f949f0a","modified":1567477393040},{"_id":"source/images/tcpopen3way.png","hash":"72d091de92a6b6dbd9b65a4a491a995d1130e7f2","modified":1567477494697},{"_id":"source/tags/index.md","hash":"91e1a612f412ac925564fd8eb6083c3e71c0b881","modified":1566199076218},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1565947710335},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1565947710335},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1565947710335},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1565947710335},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1565947710335},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1565947710335},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1565947710335},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1565947710336},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1565947710336},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1565947710336},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1565947710336},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1565947710336},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1565947710336},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1565947710337},{"_id":"themes/next/languages/zh-Hans.yml","hash":"9e0445c5b9074e9b0c3f0af50b9729ffffa3e580","modified":1571808237249},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1565947710337},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1565947710337},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1565947710351},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1565947710351},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1565947710351},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1565947710351},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1565947710351},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1565947710352},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1565947710352},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1565947710352},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1565947710353},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1565947710415},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1565947710416},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1565947710416},{"_id":"source/images/macro_1.png","hash":"8fac26debd73c9e951f3fc379dc58c6752c3b2aa","modified":1568086373127},{"_id":"source/images/rgb2yuv.png","hash":"c7e3e195b98c7f26e2998bcdd7b786f5cf7b2db3","modified":1571300404877},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710373},{"_id":"source/images/timg.jpeg","hash":"d5e7c63769062a8caab9370a20875ba27682e5a1","modified":1567407617937},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1565947710337},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1565947710337},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1565947710338},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1565947710338},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1565947710338},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1565947710340},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1565947710338},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1565947710338},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1565947710340},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1565947710340},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1565947710340},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1565947710341},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1565947710341},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1565947710342},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1565947710342},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1565947710343},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1565947710343},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1565947710344},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1565947710349},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1565947710348},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1565947710349},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1565947710349},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1565947710348},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1565947710349},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1565947710349},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1565947710353},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1565947710353},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1565947710354},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1565947710354},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1565947710354},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1565947710354},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1565947710354},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1565947710354},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1565947710354},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1565947710373},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1565947710374},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1565947710374},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1565947710374},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1565947710375},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1565947710375},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1565947710375},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1565947710376},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1565947710375},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1565947710376},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1565947710376},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1565947710376},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1565947710376},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565947710377},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1565947710377},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565947710377},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1565947710377},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1565947710377},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1565947710377},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710344},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710344},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710368},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710368},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710368},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710372},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565947710373},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1565947710341},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1565947710341},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1565947710342},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1565947710342},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1565947710342},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1565947710342},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1565947710343},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1565947710343},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1565947710343},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1565947710344},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1565947710344},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1565947710344},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1565947710344},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1565947710345},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1565947710346},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1565947710346},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1565947710346},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1565947710346},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1565947710346},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1565947710346},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1565947710347},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1565947710347},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1565947710347},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1565947710347},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1565947710347},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1565947710348},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1565947710348},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1565947710348},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1565947710350},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1565947710350},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1565947710350},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1565947710350},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1565947710367},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1565947710367},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1565947710368},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1565947710368},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1565947710372},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1565947710372},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1565947710372},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1565947710372},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1565947710377},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1565947710378},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1565947710378},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1565947710378},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1565947710378},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1565947710378},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1565947710378},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1565947710379},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1565947710379},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1565947710379},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1565947710379},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1565947710382},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1565947710385},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1565947710386},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1565947710385},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1565947710386},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1565947710389},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1565947710389},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1565947710390},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1565947710392},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1565947710391},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1565947710392},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1565947710392},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1565947710392},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1565947710403},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1565947710404},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1565947710404},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1565947710404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1565947710404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1565947710404},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1565947710405},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1565947710405},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1565947710405},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1565947710406},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1565947710405},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1565947710406},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1565947710407},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1565947710407},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1565947710407},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1565947710407},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1565947710407},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1565947710407},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1565947710408},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1565947710408},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1565947710408},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1565947710412},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1565947710412},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1565947710413},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1565947710414},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1565947710414},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1565947710403},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1565947710349},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1565947710350},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1565947710362},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1565947710366},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1565947710366},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1565947710366},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1565947710366},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1565947710367},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1565947710367},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1565947710367},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1565947710368},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1565947710369},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1565947710371},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1565947710372},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1565947710379},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1565947710381},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1565947710382},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1565947710382},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1565947710386},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1565947710386},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1565947710386},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1565947710386},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1565947710387},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1565947710386},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1565947710388},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1565947710389},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1565947710388},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1565947710391},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1565947710391},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1565947710393},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1565947710393},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1565947710394},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1565947710411},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1565947710411},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1565947710381},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1565947710403},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1565947710413},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1565947710355},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1565947710356},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1565947710356},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1565947710356},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1565947710356},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1565947710356},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1565947710357},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1565947710357},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1565947710357},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1565947710357},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1565947710357},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1565947710358},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1565947710359},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1565947710360},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1565947710361},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1565947710362},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1565947710362},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1565947710362},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1565947710362},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1565947710362},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1565947710363},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1565947710364},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1565947710364},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1565947710364},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1565947710364},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1565947710364},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1565947710365},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1565947710365},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1565947710365},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1565947710365},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1565947710365},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1565947710365},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1565947710370},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1565947710371},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1565947710380},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1565947710380},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1565947710380},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1565947710380},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1565947710381},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1565947710387},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1565947710387},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1565947710387},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1565947710388},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1565947710387},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1565947710388},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1565947710402},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1565947710397},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1565947710395},{"_id":"source/images/state_machine.png","hash":"84d835bd692f46b9309390c263410f2fb261250a","modified":1567500794229},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1565947710402},{"_id":"source/images/tcp_close_state_machine.png","hash":"1055fba87e5f286114f7d2cc030c0671cfef45f4","modified":1567503539907},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1565947710385},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1565947710411},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1565947710400},{"_id":"public/tags/index.html","hash":"d889f36994ae681b31d9975cfe0a5cf0217b9174","modified":1571808727375},{"_id":"public/categories/Cocoa/index.html","hash":"c9dd9fafa5870c77246a28018742f739cd589575","modified":1571808727375},{"_id":"public/categories/index.html","hash":"37bc9aa63236461f19be35fbf1c4f00ca9c2764b","modified":1571808727376},{"_id":"public/2019/10/17/iOS-RGBA转YV12/index.html","hash":"58bfbad7db8a60130488cfc80e2a9f2897e23f6f","modified":1571809992851},{"_id":"public/2019/09/19/mysql重置密码/index.html","hash":"39575c8bf0fe8961a862434da7b5389bc9adef61","modified":1571808727376},{"_id":"public/2019/10/14/ARC详解/index.html","hash":"672b504df20a179ce0dd7523206d0c8eb74f9d83","modified":1571808727376},{"_id":"public/2019/09/10/C、CPlusPlus格式化字符串/index.html","hash":"18f71a47329bcd650e311b0eb0fcce3a2211ed5e","modified":1571808727376},{"_id":"public/2019/09/02/TCP的三次握手与四次挥手/index.html","hash":"e64eca1d08c36d0c35337674af90e5da42358328","modified":1571808727377},{"_id":"public/2019/08/20/C-中调用OC代码/index.html","hash":"6b865a019ac525e70304f2c5920a4ab028fdc074","modified":1571808727377},{"_id":"public/2019/08/20/Mac-OpenGL环境搭建/index.html","hash":"f044356edc83725da93a9b500c7e78f5cee096c0","modified":1571808727377},{"_id":"public/2019/08/19/initial-blog/index.html","hash":"ad909c03447ed35e8d630a473671ac57019af0e0","modified":1571808727377},{"_id":"public/categories/Objective-C/index.html","hash":"9be453d00758980f57998f3d2d3ff9dfa24ef18e","modified":1571808727378},{"_id":"public/categories/sundry/index.html","hash":"de3579d3b9738e12b398fad33e53e302d625ad47","modified":1571809992851},{"_id":"public/categories/OpenGL/index.html","hash":"62c1418544376f53dd2f6f8bae020ec9545b6197","modified":1571808727378},{"_id":"public/categories/net/index.html","hash":"5dad49141d209ddb6c91e166566938ddbdb0c934","modified":1571808727378},{"_id":"public/index.html","hash":"fc50e61ad3d4cb0173878705de3ad6ccd37105a1","modified":1571809992851},{"_id":"public/archives/index.html","hash":"acaf72fe07487c729f9ade2bb701705333946cbf","modified":1571809992851},{"_id":"public/archives/2019/index.html","hash":"bd8e9774a34dff5b3415994be9b40e9334f45949","modified":1571809992851},{"_id":"public/archives/2019/08/index.html","hash":"73414fadadd53c1b1d67c9aadb602132c5fbb353","modified":1571808727377},{"_id":"public/archives/2019/09/index.html","hash":"71085683c129a0c27fc438457fcc4d1757965701","modified":1571808727377},{"_id":"public/archives/2019/10/index.html","hash":"f5ef6a42b68b85ed8f33dfbb065e26ac4dadab6d","modified":1571809992851},{"_id":"public/categories/DesignPattern/index.html","hash":"d08964ce9e1a564ae3ce20eeaaf6511e3dd935bf","modified":1571808727376},{"_id":"public/2019/10/23/杂记/index.html","hash":"91b2e623e43e9940667ab28cd7275eaaef0ddb4f","modified":1571808727376},{"_id":"public/images/tcpfsm1.png","hash":"34c92f937d294d778591f86b31e6ae895f949f0a","modified":1571808115506},{"_id":"public/images/tcpopen3way.png","hash":"72d091de92a6b6dbd9b65a4a491a995d1130e7f2","modified":1571808115506},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1571808115506},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1571808115506},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1571808115506},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1571808115506},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1571808115506},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1571808115506},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1571808115506},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1571808115506},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1571808115506},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1571808115506},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1571808115506},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1571808115506},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571808115507},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1571808115507},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1571808115507},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1571808115507},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1571808115507},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1571808115507},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1571808115507},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1571808115507},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1571808115507},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1571808115507},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1571808115507},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1571808115507},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1571808115507},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1571808115507},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1571808115507},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1571808115507},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1571808115507},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1571808115507},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1571808115507},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1571808115507},{"_id":"public/images/tcp3waysynch.png","hash":"0e7bee13918ed0d1eb55a887b82c529500468120","modified":1571808115953},{"_id":"public/images/tcpclose1.png","hash":"805ec3ea6d462b4bb451a017292922e634c84fb9","modified":1571808115954},{"_id":"public/images/macro_1.png","hash":"8fac26debd73c9e951f3fc379dc58c6752c3b2aa","modified":1571808115964},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571808115964},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1571808115964},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571808115964},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1571808115973},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1571808115973},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1571808115973},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1571808115973},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1571808115973},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1571808115973},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1571808115973},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1571808115973},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1571808115973},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1571808115974},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1571808115974},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1571808115974},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1571808115974},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1571808115974},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1571808115974},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1571808115974},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1571808115974},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1571808115974},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1571808115974},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1571808115974},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1571808115975},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1571808115975},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1571808115975},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1571808115975},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1571808115975},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1571808115975},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1571808115975},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1571808115975},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1571808115975},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1571808115975},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1571808115975},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1571808115975},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1571808115975},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1571808115975},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1571808115975},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1571808115975},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1571808115975},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1571808115976},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1571808115976},{"_id":"public/css/main.css","hash":"7c9df271b4e73df6ecb7e205531c2aaf55375faa","modified":1571808115976},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1571808115976},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1571808115976},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1571808115976},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1571808115976},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1571808115976},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1571808115976},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1571808115976},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1571808115976},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1571808115976},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1571808115976},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1571808115976},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1571808115976},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1571808115976},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1571808115976},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1571808115977},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1571808115977},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1571808115977},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1571808115977},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1571808115977},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1571808115977},{"_id":"public/images/rgb2yuv.png","hash":"c7e3e195b98c7f26e2998bcdd7b786f5cf7b2db3","modified":1571808115977},{"_id":"public/images/timg.jpeg","hash":"d5e7c63769062a8caab9370a20875ba27682e5a1","modified":1571808115977},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571808115977},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1571808115978},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1571808115978},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1571808115994},{"_id":"public/images/state_machine.png","hash":"84d835bd692f46b9309390c263410f2fb261250a","modified":1571808115995},{"_id":"public/images/tcp_close_state_machine.png","hash":"1055fba87e5f286114f7d2cc030c0671cfef45f4","modified":1571808115995},{"_id":"source/_posts/Mac 设置socket5代理.md","hash":"a8d27798513914f2ec1f93b4906456e77cc0cb5e","modified":1571809979685},{"_id":"source/images/proxy_2.png","hash":"d2e0b632147817749add3714e5293eadd7f8821b","modified":1571809297579},{"_id":"source/images/proxy_3.png","hash":"a863aa7f1aa1150d5b125e6544bd15c4a3a0361f","modified":1571809373453},{"_id":"source/images/proxy_1.png","hash":"b3a92878ffb7a1fa1a36f74375c469125c1dc6af","modified":1571809254030},{"_id":"public/2019/10/23/Mac 设置socket5代理/index.html","hash":"377db0fe6f62b8721bfcd67e7a5d36cb1d598abc","modified":1571809992853},{"_id":"public/images/proxy_2.png","hash":"d2e0b632147817749add3714e5293eadd7f8821b","modified":1571809992856},{"_id":"public/images/proxy_3.png","hash":"a863aa7f1aa1150d5b125e6544bd15c4a3a0361f","modified":1571809992856},{"_id":"public/images/proxy_1.png","hash":"b3a92878ffb7a1fa1a36f74375c469125c1dc6af","modified":1571809992857}],"Category":[{"name":"Objective-C","_id":"ck22tyukn0005oqs61iuezuri"},{"name":"sundry","_id":"ck22tyuks0008oqs6qok3himu"},{"name":"OpenGL","_id":"ck22tyul1000foqs6w9f7roik"},{"name":"net","_id":"ck22tyul2000ioqs67bpy7k8y"},{"name":"Cocoa","_id":"ck22tyul5000poqs6zv0i6qot"},{"name":"DesignPattern","_id":"ck22tyul6000qoqs689rylyfb"}],"Data":[],"Page":[{"title":"分类","date":"2014-12-22T12:39:04.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2014-12-22 12:39:04\ntype: \"categories\"\n---\n","updated":"2019-08-19T07:45:41.907Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck22tyukg0001oqs6vm876vq3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2019-08-16T18:38:24.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-08-16 18:38:24\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-08-19T07:17:56.218Z","path":"tags/index.html","layout":"page","_id":"ck22tyukk0003oqs6omj6cfrk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ARC详解","date":"2019-10-14T15:03:14.000Z","_content":"\n# 引言：\n\nObjective-C（以下简称OC）的内存管理是通过引用计数来完成的，具体来说有两种方式。以前呢，我们是通过MRC（Manual Reference Counting 手动引用计数）的方式来管理，而现在呢，现在苹果官方是推荐我们使用ARC（Automatic Reference Counting 自动引用计数）。\n\n# 正文\n\n## 内存管理基础知识\n\noc中对对象的引用计数retain count有影响的方法有：retain、release、autorelease等，其中retain会使对象的引用计数+1，而release与autorelease会使对象的引用计数减一。当执行release后，如果对象的引用计数减少为0，则执行对象的dealloc方法，来释放内存。总结起来就是：\n\n- retain 递增引用计数\n- release 递减引用计数\n- autorelease 在自动释放池 pop时，再递减引用计数\n\n## MRC 手动引用计数\n\n在MRC管理方式中，管理原则是谁创建谁释放，即一个对象或者一个方法alloc或者retain了对象了，在使用完毕后，一定要执行release或者autorelease方法。如：\n\n```objective-c\nNSObject *obj = [[NSObject alloc] init];\n//do something ...\n[obj release];\n```\n\n在平时的编码过程中，我们需要创建和销毁非常多的对象，如果通过MRC的方式来管理的话，工作量会非常的繁琐，于是乎苹果的工程师为我们提供了更便捷的管理方式ARC。\n\n## ARC 自动引用计数\n\n### ARC简介\n\n简单来说ARC的作用是编译器在编译的时候，帮我们加入适当的release和retain调用。例如在ARC中的如下代码：\n\n```objc\n- (void)foo\n{\n    NSObject *object = [[NSObject alloc] init];\n    NSLog(@\"%@\", object);\n}\n```\n\n上面这段代码，在ARC中会被改写为如下形式：\n\n```objc\n- (void)foo\n{\n    NSObject *object = [[NSObject alloc] init];\n    NSLog(@\"%@\", object);\n    [object release]; //ARC添加的\n}\n```\n\n由此可见，在ARC的管理方式下，引用计数任然是有效的，只是release与retain操作交给ARC自动添加了。因为ARC会自动为我们添加内存管理语义，所以在ARC下是不能主动调用内存管理语义的，具体如下：\n\n- retain\n- release\n- autorelease\n- dealloc\n\n熟悉MRC的人可能会觉得ARC只是替我们调用了release与retain等方法，其实ARC并不是直接通过消息派发机制来调用的，而是直接通过调用底层的C语言版本。C语言对应的方法如下：\n\n- retain -> objc_retain\n- release -> objc_release\n- autorelease -> objc_autorelease\n\n### ARC命名规则\n\n总的来说ARC下的内存管理是通过命名规则来决定对象的管理权的归属，具体来说通过以下名称开头产生的对象管理权归调用者所有：\n\n- alloc\n- new\n- copy\n- mutableCopy\n\n如果不是通过以上语句开头产生的，那么则有被调用方管理，ARC会在创建方法末尾添加调用autorelease。\n\n示例如下：\n\n```objc\n@implementation Student\n+ (id)newStudent:(NSString *)name\n{\n    Student *stu = [[Student alloc] init];\n    stu.name = name;\n    //管理权归被调用方所有\n    return stu;\n}\n\n+ (id)studentWithName:(NSString *)name\n{\n    Student *stu = [[Student alloc] init];\n    /**\n     在arc下管理权归被调用者\n     return [stu autorelease];\n     */\n    stu.name = name;\n    return stu;\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%@ dealloc\", self.name);\n}\n\n\n\n@end\n\nvoid foo2()\n{\n    NSLog(@\"%s begin\", __func__);\n    {\n        Student *stu1, *stu2;\n        stu1 = [Student newStudent:@\"Jacky\"];\n        /**\n         [stu1 release];\n         */\n        stu2 = [Student studentWithName:@\"Nacy\"];\n    }\n        NSLog(@\"%s end\", __func__);\n}\n\n```\n\n运行结果：\n\n```text\n2019-10-14 18:06:19.802799+0800 Test_ARC[9252:11351467] foo2 begin\n2019-10-14 18:06:19.802865+0800 Test_ARC[9252:11351467] Jacky dealloc\n2019-10-14 18:06:30.592471+0800 Test_ARC[9252:11351467] foo2 end\n2019-10-14 18:06:33.308012+0800 Test_ARC[9252:11351467] Nacy dealloc\n```\n\n可能你会对这个运行结果存在疑惑，正常来说stu1与stu2的生命周期都应该在=={}==中，出了中括号这两个变量都应该销毁，变量销毁后，指向的对象也应该马上销毁。但是只有stu1在生命周期结束后销毁了，而stu2却延迟销毁了。为什么会这样呢，就像之前介绍说到的，stu2是通过==studentWithName==创建的，这不符合ARC中管理规则，所以stu2是以autorelease的方式返回的，内存管理方式是交给被调用方的。同理，就可以明白stu1会在变量作用于结束时销毁的原理了\n\n### ARC的优化\n\n#### 优化一 成对的retain与autorelease优化\n\n上面讲到，如果对象是通过不符合ARC规则的方法创建的，那么ARC会为其加上autorelease，如果这时候接收的变量是强指针的话，那么ARC会为其加上retain调用。示例如下：\n\n```objc\nStudent *stu = [Student studentWithName:@\"Nacy\"];\n/**\n在arc处理后代码变为\nStudent *stu = [Student studentWithName:@\"Nacy\"];\n[stu retain];\n*/\n```\n\n这样看来的话，在这里studentWithName中的autorelease与这里的retain就是多余的了，可以删除。但是为了兼容性，ARC没有直接删除。ARC不会直接调用autorelease，而是执行另外的函数objc_autoreleaseReturnValue。这个函数会检查返回值之后的代码，如果之后的代码有执行retain操作，那么就设置全局结构，不执行autorelease操作。同样的，在调用retain方法时，会调用objc_retainAutoreleasedReturnValue。这个方法会检查上面提到的标志位，如果标志位被设置了的话，那么就不会执行retain操作，并重置检测标志位。\n\n#### 优化二 设置实例变量\n\n在MRC情况下，setter方法的内存管理是这样的\n\n```objc\n- (void)setObj:(id)obj\n{\n    id newObj = [obj retain]; //保留新值\n    [_obj release]; //释放旧值\n    _obj = newObj; //设置实例变量\n}\n```\n\n但是在ARC下面，只需要设置实例变量即可，ARC会自动保留新值，释放旧值，最后才设置实例变量，就像是上面这样写的一样，ARC代码如下：\n\n```objc\n- (void)setObj:(id)obj\n{\n    _obj = obj; //设置实例变量\n}\n```\n\n# 总结\n\n- ARC通过方法名来管理方法返回的对象\n- ARC会优化成对的retain与release操作\n- ARC只管理OC对象\n\n# 参考\n\n[Effective Objective-C 2.0](https://item.jd.com/11402853.html)\n\n","source":"_posts/ARC详解.md","raw":"---\ntitle: ARC详解\ndate: 2019-10-14 15:03:14\ncategories:\n- [Objective-C]\n---\n\n# 引言：\n\nObjective-C（以下简称OC）的内存管理是通过引用计数来完成的，具体来说有两种方式。以前呢，我们是通过MRC（Manual Reference Counting 手动引用计数）的方式来管理，而现在呢，现在苹果官方是推荐我们使用ARC（Automatic Reference Counting 自动引用计数）。\n\n# 正文\n\n## 内存管理基础知识\n\noc中对对象的引用计数retain count有影响的方法有：retain、release、autorelease等，其中retain会使对象的引用计数+1，而release与autorelease会使对象的引用计数减一。当执行release后，如果对象的引用计数减少为0，则执行对象的dealloc方法，来释放内存。总结起来就是：\n\n- retain 递增引用计数\n- release 递减引用计数\n- autorelease 在自动释放池 pop时，再递减引用计数\n\n## MRC 手动引用计数\n\n在MRC管理方式中，管理原则是谁创建谁释放，即一个对象或者一个方法alloc或者retain了对象了，在使用完毕后，一定要执行release或者autorelease方法。如：\n\n```objective-c\nNSObject *obj = [[NSObject alloc] init];\n//do something ...\n[obj release];\n```\n\n在平时的编码过程中，我们需要创建和销毁非常多的对象，如果通过MRC的方式来管理的话，工作量会非常的繁琐，于是乎苹果的工程师为我们提供了更便捷的管理方式ARC。\n\n## ARC 自动引用计数\n\n### ARC简介\n\n简单来说ARC的作用是编译器在编译的时候，帮我们加入适当的release和retain调用。例如在ARC中的如下代码：\n\n```objc\n- (void)foo\n{\n    NSObject *object = [[NSObject alloc] init];\n    NSLog(@\"%@\", object);\n}\n```\n\n上面这段代码，在ARC中会被改写为如下形式：\n\n```objc\n- (void)foo\n{\n    NSObject *object = [[NSObject alloc] init];\n    NSLog(@\"%@\", object);\n    [object release]; //ARC添加的\n}\n```\n\n由此可见，在ARC的管理方式下，引用计数任然是有效的，只是release与retain操作交给ARC自动添加了。因为ARC会自动为我们添加内存管理语义，所以在ARC下是不能主动调用内存管理语义的，具体如下：\n\n- retain\n- release\n- autorelease\n- dealloc\n\n熟悉MRC的人可能会觉得ARC只是替我们调用了release与retain等方法，其实ARC并不是直接通过消息派发机制来调用的，而是直接通过调用底层的C语言版本。C语言对应的方法如下：\n\n- retain -> objc_retain\n- release -> objc_release\n- autorelease -> objc_autorelease\n\n### ARC命名规则\n\n总的来说ARC下的内存管理是通过命名规则来决定对象的管理权的归属，具体来说通过以下名称开头产生的对象管理权归调用者所有：\n\n- alloc\n- new\n- copy\n- mutableCopy\n\n如果不是通过以上语句开头产生的，那么则有被调用方管理，ARC会在创建方法末尾添加调用autorelease。\n\n示例如下：\n\n```objc\n@implementation Student\n+ (id)newStudent:(NSString *)name\n{\n    Student *stu = [[Student alloc] init];\n    stu.name = name;\n    //管理权归被调用方所有\n    return stu;\n}\n\n+ (id)studentWithName:(NSString *)name\n{\n    Student *stu = [[Student alloc] init];\n    /**\n     在arc下管理权归被调用者\n     return [stu autorelease];\n     */\n    stu.name = name;\n    return stu;\n}\n\n- (void)dealloc\n{\n    NSLog(@\"%@ dealloc\", self.name);\n}\n\n\n\n@end\n\nvoid foo2()\n{\n    NSLog(@\"%s begin\", __func__);\n    {\n        Student *stu1, *stu2;\n        stu1 = [Student newStudent:@\"Jacky\"];\n        /**\n         [stu1 release];\n         */\n        stu2 = [Student studentWithName:@\"Nacy\"];\n    }\n        NSLog(@\"%s end\", __func__);\n}\n\n```\n\n运行结果：\n\n```text\n2019-10-14 18:06:19.802799+0800 Test_ARC[9252:11351467] foo2 begin\n2019-10-14 18:06:19.802865+0800 Test_ARC[9252:11351467] Jacky dealloc\n2019-10-14 18:06:30.592471+0800 Test_ARC[9252:11351467] foo2 end\n2019-10-14 18:06:33.308012+0800 Test_ARC[9252:11351467] Nacy dealloc\n```\n\n可能你会对这个运行结果存在疑惑，正常来说stu1与stu2的生命周期都应该在=={}==中，出了中括号这两个变量都应该销毁，变量销毁后，指向的对象也应该马上销毁。但是只有stu1在生命周期结束后销毁了，而stu2却延迟销毁了。为什么会这样呢，就像之前介绍说到的，stu2是通过==studentWithName==创建的，这不符合ARC中管理规则，所以stu2是以autorelease的方式返回的，内存管理方式是交给被调用方的。同理，就可以明白stu1会在变量作用于结束时销毁的原理了\n\n### ARC的优化\n\n#### 优化一 成对的retain与autorelease优化\n\n上面讲到，如果对象是通过不符合ARC规则的方法创建的，那么ARC会为其加上autorelease，如果这时候接收的变量是强指针的话，那么ARC会为其加上retain调用。示例如下：\n\n```objc\nStudent *stu = [Student studentWithName:@\"Nacy\"];\n/**\n在arc处理后代码变为\nStudent *stu = [Student studentWithName:@\"Nacy\"];\n[stu retain];\n*/\n```\n\n这样看来的话，在这里studentWithName中的autorelease与这里的retain就是多余的了，可以删除。但是为了兼容性，ARC没有直接删除。ARC不会直接调用autorelease，而是执行另外的函数objc_autoreleaseReturnValue。这个函数会检查返回值之后的代码，如果之后的代码有执行retain操作，那么就设置全局结构，不执行autorelease操作。同样的，在调用retain方法时，会调用objc_retainAutoreleasedReturnValue。这个方法会检查上面提到的标志位，如果标志位被设置了的话，那么就不会执行retain操作，并重置检测标志位。\n\n#### 优化二 设置实例变量\n\n在MRC情况下，setter方法的内存管理是这样的\n\n```objc\n- (void)setObj:(id)obj\n{\n    id newObj = [obj retain]; //保留新值\n    [_obj release]; //释放旧值\n    _obj = newObj; //设置实例变量\n}\n```\n\n但是在ARC下面，只需要设置实例变量即可，ARC会自动保留新值，释放旧值，最后才设置实例变量，就像是上面这样写的一样，ARC代码如下：\n\n```objc\n- (void)setObj:(id)obj\n{\n    _obj = obj; //设置实例变量\n}\n```\n\n# 总结\n\n- ARC通过方法名来管理方法返回的对象\n- ARC会优化成对的retain与release操作\n- ARC只管理OC对象\n\n# 参考\n\n[Effective Objective-C 2.0](https://item.jd.com/11402853.html)\n\n","slug":"ARC详解","published":1,"updated":"2019-10-15T03:54:26.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyukc0000oqs6whmeyjro","content":"<h1 id=\"引言：\"><a href=\"#引言：\" class=\"headerlink\" title=\"引言：\"></a>引言：</h1><p>Objective-C（以下简称OC）的内存管理是通过引用计数来完成的，具体来说有两种方式。以前呢，我们是通过MRC（Manual Reference Counting 手动引用计数）的方式来管理，而现在呢，现在苹果官方是推荐我们使用ARC（Automatic Reference Counting 自动引用计数）。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"内存管理基础知识\"><a href=\"#内存管理基础知识\" class=\"headerlink\" title=\"内存管理基础知识\"></a>内存管理基础知识</h2><p>oc中对对象的引用计数retain count有影响的方法有：retain、release、autorelease等，其中retain会使对象的引用计数+1，而release与autorelease会使对象的引用计数减一。当执行release后，如果对象的引用计数减少为0，则执行对象的dealloc方法，来释放内存。总结起来就是：</p>\n<ul>\n<li>retain 递增引用计数</li>\n<li>release 递减引用计数</li>\n<li>autorelease 在自动释放池 pop时，再递减引用计数</li>\n</ul>\n<h2 id=\"MRC-手动引用计数\"><a href=\"#MRC-手动引用计数\" class=\"headerlink\" title=\"MRC 手动引用计数\"></a>MRC 手动引用计数</h2><p>在MRC管理方式中，管理原则是谁创建谁释放，即一个对象或者一个方法alloc或者retain了对象了，在使用完毕后，一定要执行release或者autorelease方法。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSObject *obj = [[NSObject alloc] init];</span><br><span class=\"line\">//do something ...</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n\n<p>在平时的编码过程中，我们需要创建和销毁非常多的对象，如果通过MRC的方式来管理的话，工作量会非常的繁琐，于是乎苹果的工程师为我们提供了更便捷的管理方式ARC。</p>\n<h2 id=\"ARC-自动引用计数\"><a href=\"#ARC-自动引用计数\" class=\"headerlink\" title=\"ARC 自动引用计数\"></a>ARC 自动引用计数</h2><h3 id=\"ARC简介\"><a href=\"#ARC简介\" class=\"headerlink\" title=\"ARC简介\"></a>ARC简介</h3><p>简单来说ARC的作用是编译器在编译的时候，帮我们加入适当的release和retain调用。例如在ARC中的如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> *object = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, object);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码，在ARC中会被改写为如下形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> *object = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, object);</span><br><span class=\"line\">    [object release]; <span class=\"comment\">//ARC添加的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，在ARC的管理方式下，引用计数任然是有效的，只是release与retain操作交给ARC自动添加了。因为ARC会自动为我们添加内存管理语义，所以在ARC下是不能主动调用内存管理语义的，具体如下：</p>\n<ul>\n<li>retain</li>\n<li>release</li>\n<li>autorelease</li>\n<li>dealloc</li>\n</ul>\n<p>熟悉MRC的人可能会觉得ARC只是替我们调用了release与retain等方法，其实ARC并不是直接通过消息派发机制来调用的，而是直接通过调用底层的C语言版本。C语言对应的方法如下：</p>\n<ul>\n<li>retain -&gt; objc_retain</li>\n<li>release -&gt; objc_release</li>\n<li>autorelease -&gt; objc_autorelease</li>\n</ul>\n<h3 id=\"ARC命名规则\"><a href=\"#ARC命名规则\" class=\"headerlink\" title=\"ARC命名规则\"></a>ARC命名规则</h3><p>总的来说ARC下的内存管理是通过命名规则来决定对象的管理权的归属，具体来说通过以下名称开头产生的对象管理权归调用者所有：</p>\n<ul>\n<li>alloc</li>\n<li>new</li>\n<li>copy</li>\n<li>mutableCopy</li>\n</ul>\n<p>如果不是通过以上语句开头产生的，那么则有被调用方管理，ARC会在创建方法末尾添加调用autorelease。</p>\n<p>示例如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)newStudent:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Student *stu = [[Student alloc] init];</span><br><span class=\"line\">    stu.name = name;</span><br><span class=\"line\">    <span class=\"comment\">//管理权归被调用方所有</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)studentWithName:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Student *stu = [[Student alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     在arc下管理权归被调用者</span></span><br><span class=\"line\"><span class=\"comment\">     return [stu autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    stu.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ dealloc\"</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> foo2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s begin\"</span>, __func__);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Student *stu1, *stu2;</span><br><span class=\"line\">        stu1 = [Student newStudent:<span class=\"string\">@\"Jacky\"</span>];</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         [stu1 release];</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stu2 = [Student studentWithName:<span class=\"string\">@\"Nacy\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s end\"</span>, __func__);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-10-14 18:06:19.802799+0800 Test_ARC[9252:11351467] foo2 begin</span><br><span class=\"line\">2019-10-14 18:06:19.802865+0800 Test_ARC[9252:11351467] Jacky dealloc</span><br><span class=\"line\">2019-10-14 18:06:30.592471+0800 Test_ARC[9252:11351467] foo2 end</span><br><span class=\"line\">2019-10-14 18:06:33.308012+0800 Test_ARC[9252:11351467] Nacy dealloc</span><br></pre></td></tr></table></figure>\n\n<p>可能你会对这个运行结果存在疑惑，正常来说stu1与stu2的生命周期都应该在=={}==中，出了中括号这两个变量都应该销毁，变量销毁后，指向的对象也应该马上销毁。但是只有stu1在生命周期结束后销毁了，而stu2却延迟销毁了。为什么会这样呢，就像之前介绍说到的，stu2是通过==studentWithName==创建的，这不符合ARC中管理规则，所以stu2是以autorelease的方式返回的，内存管理方式是交给被调用方的。同理，就可以明白stu1会在变量作用于结束时销毁的原理了</p>\n<h3 id=\"ARC的优化\"><a href=\"#ARC的优化\" class=\"headerlink\" title=\"ARC的优化\"></a>ARC的优化</h3><h4 id=\"优化一-成对的retain与autorelease优化\"><a href=\"#优化一-成对的retain与autorelease优化\" class=\"headerlink\" title=\"优化一 成对的retain与autorelease优化\"></a>优化一 成对的retain与autorelease优化</h4><p>上面讲到，如果对象是通过不符合ARC规则的方法创建的，那么ARC会为其加上autorelease，如果这时候接收的变量是强指针的话，那么ARC会为其加上retain调用。示例如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu = [Student studentWithName:<span class=\"string\">@\"Nacy\"</span>];</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">在arc处理后代码变为</span></span><br><span class=\"line\"><span class=\"comment\">Student *stu = [Student studentWithName:@\"Nacy\"];</span></span><br><span class=\"line\"><span class=\"comment\">[stu retain];</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>这样看来的话，在这里studentWithName中的autorelease与这里的retain就是多余的了，可以删除。但是为了兼容性，ARC没有直接删除。ARC不会直接调用autorelease，而是执行另外的函数objc_autoreleaseReturnValue。这个函数会检查返回值之后的代码，如果之后的代码有执行retain操作，那么就设置全局结构，不执行autorelease操作。同样的，在调用retain方法时，会调用objc_retainAutoreleasedReturnValue。这个方法会检查上面提到的标志位，如果标志位被设置了的话，那么就不会执行retain操作，并重置检测标志位。</p>\n<h4 id=\"优化二-设置实例变量\"><a href=\"#优化二-设置实例变量\" class=\"headerlink\" title=\"优化二 设置实例变量\"></a>优化二 设置实例变量</h4><p>在MRC情况下，setter方法的内存管理是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObj:(<span class=\"keyword\">id</span>)obj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> newObj = [obj <span class=\"keyword\">retain</span>]; <span class=\"comment\">//保留新值</span></span><br><span class=\"line\">    [_obj release]; <span class=\"comment\">//释放旧值</span></span><br><span class=\"line\">    _obj = newObj; <span class=\"comment\">//设置实例变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是在ARC下面，只需要设置实例变量即可，ARC会自动保留新值，释放旧值，最后才设置实例变量，就像是上面这样写的一样，ARC代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObj:(<span class=\"keyword\">id</span>)obj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _obj = obj; <span class=\"comment\">//设置实例变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>ARC通过方法名来管理方法返回的对象</li>\n<li>ARC会优化成对的retain与release操作</li>\n<li>ARC只管理OC对象</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://item.jd.com/11402853.html\" target=\"_blank\" rel=\"noopener\">Effective Objective-C 2.0</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言：\"><a href=\"#引言：\" class=\"headerlink\" title=\"引言：\"></a>引言：</h1><p>Objective-C（以下简称OC）的内存管理是通过引用计数来完成的，具体来说有两种方式。以前呢，我们是通过MRC（Manual Reference Counting 手动引用计数）的方式来管理，而现在呢，现在苹果官方是推荐我们使用ARC（Automatic Reference Counting 自动引用计数）。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"内存管理基础知识\"><a href=\"#内存管理基础知识\" class=\"headerlink\" title=\"内存管理基础知识\"></a>内存管理基础知识</h2><p>oc中对对象的引用计数retain count有影响的方法有：retain、release、autorelease等，其中retain会使对象的引用计数+1，而release与autorelease会使对象的引用计数减一。当执行release后，如果对象的引用计数减少为0，则执行对象的dealloc方法，来释放内存。总结起来就是：</p>\n<ul>\n<li>retain 递增引用计数</li>\n<li>release 递减引用计数</li>\n<li>autorelease 在自动释放池 pop时，再递减引用计数</li>\n</ul>\n<h2 id=\"MRC-手动引用计数\"><a href=\"#MRC-手动引用计数\" class=\"headerlink\" title=\"MRC 手动引用计数\"></a>MRC 手动引用计数</h2><p>在MRC管理方式中，管理原则是谁创建谁释放，即一个对象或者一个方法alloc或者retain了对象了，在使用完毕后，一定要执行release或者autorelease方法。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSObject *obj = [[NSObject alloc] init];</span><br><span class=\"line\">//do something ...</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n\n<p>在平时的编码过程中，我们需要创建和销毁非常多的对象，如果通过MRC的方式来管理的话，工作量会非常的繁琐，于是乎苹果的工程师为我们提供了更便捷的管理方式ARC。</p>\n<h2 id=\"ARC-自动引用计数\"><a href=\"#ARC-自动引用计数\" class=\"headerlink\" title=\"ARC 自动引用计数\"></a>ARC 自动引用计数</h2><h3 id=\"ARC简介\"><a href=\"#ARC简介\" class=\"headerlink\" title=\"ARC简介\"></a>ARC简介</h3><p>简单来说ARC的作用是编译器在编译的时候，帮我们加入适当的release和retain调用。例如在ARC中的如下代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> *object = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, object);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码，在ARC中会被改写为如下形式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> *object = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, object);</span><br><span class=\"line\">    [object release]; <span class=\"comment\">//ARC添加的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，在ARC的管理方式下，引用计数任然是有效的，只是release与retain操作交给ARC自动添加了。因为ARC会自动为我们添加内存管理语义，所以在ARC下是不能主动调用内存管理语义的，具体如下：</p>\n<ul>\n<li>retain</li>\n<li>release</li>\n<li>autorelease</li>\n<li>dealloc</li>\n</ul>\n<p>熟悉MRC的人可能会觉得ARC只是替我们调用了release与retain等方法，其实ARC并不是直接通过消息派发机制来调用的，而是直接通过调用底层的C语言版本。C语言对应的方法如下：</p>\n<ul>\n<li>retain -&gt; objc_retain</li>\n<li>release -&gt; objc_release</li>\n<li>autorelease -&gt; objc_autorelease</li>\n</ul>\n<h3 id=\"ARC命名规则\"><a href=\"#ARC命名规则\" class=\"headerlink\" title=\"ARC命名规则\"></a>ARC命名规则</h3><p>总的来说ARC下的内存管理是通过命名规则来决定对象的管理权的归属，具体来说通过以下名称开头产生的对象管理权归调用者所有：</p>\n<ul>\n<li>alloc</li>\n<li>new</li>\n<li>copy</li>\n<li>mutableCopy</li>\n</ul>\n<p>如果不是通过以上语句开头产生的，那么则有被调用方管理，ARC会在创建方法末尾添加调用autorelease。</p>\n<p>示例如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Student</span></span></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)newStudent:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Student *stu = [[Student alloc] init];</span><br><span class=\"line\">    stu.name = name;</span><br><span class=\"line\">    <span class=\"comment\">//管理权归被调用方所有</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">id</span>)studentWithName:(<span class=\"built_in\">NSString</span> *)name</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Student *stu = [[Student alloc] init];</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     在arc下管理权归被调用者</span></span><br><span class=\"line\"><span class=\"comment\">     return [stu autorelease];</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    stu.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stu;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ dealloc\"</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> foo2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s begin\"</span>, __func__);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Student *stu1, *stu2;</span><br><span class=\"line\">        stu1 = [Student newStudent:<span class=\"string\">@\"Jacky\"</span>];</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         [stu1 release];</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        stu2 = [Student studentWithName:<span class=\"string\">@\"Nacy\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s end\"</span>, __func__);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-10-14 18:06:19.802799+0800 Test_ARC[9252:11351467] foo2 begin</span><br><span class=\"line\">2019-10-14 18:06:19.802865+0800 Test_ARC[9252:11351467] Jacky dealloc</span><br><span class=\"line\">2019-10-14 18:06:30.592471+0800 Test_ARC[9252:11351467] foo2 end</span><br><span class=\"line\">2019-10-14 18:06:33.308012+0800 Test_ARC[9252:11351467] Nacy dealloc</span><br></pre></td></tr></table></figure>\n\n<p>可能你会对这个运行结果存在疑惑，正常来说stu1与stu2的生命周期都应该在=={}==中，出了中括号这两个变量都应该销毁，变量销毁后，指向的对象也应该马上销毁。但是只有stu1在生命周期结束后销毁了，而stu2却延迟销毁了。为什么会这样呢，就像之前介绍说到的，stu2是通过==studentWithName==创建的，这不符合ARC中管理规则，所以stu2是以autorelease的方式返回的，内存管理方式是交给被调用方的。同理，就可以明白stu1会在变量作用于结束时销毁的原理了</p>\n<h3 id=\"ARC的优化\"><a href=\"#ARC的优化\" class=\"headerlink\" title=\"ARC的优化\"></a>ARC的优化</h3><h4 id=\"优化一-成对的retain与autorelease优化\"><a href=\"#优化一-成对的retain与autorelease优化\" class=\"headerlink\" title=\"优化一 成对的retain与autorelease优化\"></a>优化一 成对的retain与autorelease优化</h4><p>上面讲到，如果对象是通过不符合ARC规则的方法创建的，那么ARC会为其加上autorelease，如果这时候接收的变量是强指针的话，那么ARC会为其加上retain调用。示例如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu = [Student studentWithName:<span class=\"string\">@\"Nacy\"</span>];</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">在arc处理后代码变为</span></span><br><span class=\"line\"><span class=\"comment\">Student *stu = [Student studentWithName:@\"Nacy\"];</span></span><br><span class=\"line\"><span class=\"comment\">[stu retain];</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>这样看来的话，在这里studentWithName中的autorelease与这里的retain就是多余的了，可以删除。但是为了兼容性，ARC没有直接删除。ARC不会直接调用autorelease，而是执行另外的函数objc_autoreleaseReturnValue。这个函数会检查返回值之后的代码，如果之后的代码有执行retain操作，那么就设置全局结构，不执行autorelease操作。同样的，在调用retain方法时，会调用objc_retainAutoreleasedReturnValue。这个方法会检查上面提到的标志位，如果标志位被设置了的话，那么就不会执行retain操作，并重置检测标志位。</p>\n<h4 id=\"优化二-设置实例变量\"><a href=\"#优化二-设置实例变量\" class=\"headerlink\" title=\"优化二 设置实例变量\"></a>优化二 设置实例变量</h4><p>在MRC情况下，setter方法的内存管理是这样的</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObj:(<span class=\"keyword\">id</span>)obj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> newObj = [obj <span class=\"keyword\">retain</span>]; <span class=\"comment\">//保留新值</span></span><br><span class=\"line\">    [_obj release]; <span class=\"comment\">//释放旧值</span></span><br><span class=\"line\">    _obj = newObj; <span class=\"comment\">//设置实例变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是在ARC下面，只需要设置实例变量即可，ARC会自动保留新值，释放旧值，最后才设置实例变量，就像是上面这样写的一样，ARC代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setObj:(<span class=\"keyword\">id</span>)obj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _obj = obj; <span class=\"comment\">//设置实例变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>ARC通过方法名来管理方法返回的对象</li>\n<li>ARC会优化成对的retain与release操作</li>\n<li>ARC只管理OC对象</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://item.jd.com/11402853.html\" target=\"_blank\" rel=\"noopener\">Effective Objective-C 2.0</a></p>\n"},{"title":"C++中调用OC代码","date":"2019-08-20T13:16:19.000Z","_content":"# 前言\n\n　　最近项目中为了方便维护，底层统一使用C++编写。由于是项目是做屏幕共享sdk，所以只能底层的压缩、编解码使用C++，屏幕捕获部分Mac和win就自己实现了。那么问题就来了，因为是面向接口编程，所以项目的入口都是c++来写的，而屏幕捕获是需要oc部分的代码，就需要C++调用oc代码了。\n\n# 准备\n\n　　之前只做过OC调动C++，于是Google了一下，在Stack Overflow上找到了这个[回答](https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function)。要看具体描述的可以去链接看看，实现思路一共有两种，我在这里大概描述一下。第一种，由于C++是不能直接调用OC的，所以需要通过C语言作为中间层，即C++调用C，C调用OC，这样就达到了C++调用OC的目的。第二种OC是可以调用C++的，通过在外部声名C++类，然后类具体实现放在OC类中，这样C++类就能够调用OC类了，其他需要调用OC的类，只需要调用外部声名的类即可。\n\n# 实现\n\n具体的实现方式有两种，第一种是C语言方法接收oc对象指针和参数，然后把指针桥接为具体的oc对象。第二种是用C++进行包装，先声名一个C++类，这里称为A。然后在OC类中，这里称为B，对A进行实现，因为这个实现实在OC语言里的，所以在这里是可以直接调用OC代码的。接下来声名一个C++类C。类C通过持有类A来调用OC类B，即A（C++）->C（C++）->B(OC类)\n\n　　## 实现方式一 by C\n\n**MyObject-C-Interface.h**\n　　```\n　　int MyObjectDoSomethingWith (void *myObjectInstance, void *parameter);\n　　```\n　　\n**MyObject.h**\n　　```\n　　@interface MyObject : NSObject\n　　{\n　　int someVar;\n　　}\n　　\n\n　　- (int)doSomethingWith:(void *)aParameter;\n　　@end\n\n　　```\n　　**MyObject.mm**\n　　```\n　　@implementation MyObject\n　　\n　　int MyObjectDoSomethingWith (void *self, void *aParameter)\n　　{\n　　// 通过将self指针桥接为oc 对象来调用oc方法\n　　return [(__bridge id)self doSomethingWith:aParameter];\n　　}\n　　\n\n　　- (int) doSomethingWith:(void *) aParameter\n　　{\n　　//将void *指针强转为对应的类型\n　　int* param = (int *)aParameter;\n　　return *param / 2 ;\n　　}\n\n　　- (void)dealloc\n　　{\n　　NSLog(@\"%s\", __func__);\n　　}\n\n　　@end\n　　```\n　　**MyCPPClass.h**\n　　```\n　　class MyCPPClass {\n　　\n　　\n　　public:\n　　MyCPPClass();\n　　~MyCPPClass();\n　　int someMethod (void *objectiveCObject, void *aParameter);\n　　void *self;\n　　\n　　void setSelf(void *self);\n　　};\n　　\n　　```\n　　\n　　**MyCPPClass.cpp**\n　　\n　　```\n\n　　#include \"MyObject-C-Interface.h\"\n\n　　MyCPPClass::MyCPPClass()\n　　{\n　　\n　　}\n　　\n　　MyCPPClass::~MyCPPClass()\n　　{\n　　\n　　}\n　　\n　　\n　　int MyCPPClass::someMethod (void *objectiveCObject, void *aParameter)\n　　{\n　　// To invoke an Objective-C method from C++, use\n　　// the C trampoline function\n　　return MyObjectDoSomethingWith (objectiveCObject, aParameter);\n　　}\n　　\n　　void MyCPPClass::setSelf(void *aSelf)\n　　{\n　　self = aSelf;\n　　}\n　　\n　　```\n　　**main.mm**\n　　\n　　```\n\n　　#include \"MyCPPClass.hpp\"\n　　#import \"MyObject.h\"\n\n　　int main(int argc, const char * argv[]) {\n　　@autoreleasepool {\n　　// insert code here...\n　　NSLog(@\"Hello, World!\");\n　　MyObject *object = [[MyObject alloc] init];\n　　MyCPPClass *c = new MyCPPClass();\n　　c->setSelf((__bridge void *)object);\n　　int a = 12;\n　　int result = c->someMethod((__bridge void *)object, &a);\n　　NSLog(@\"%d\", result);\n　　}\n　　return 0;\n　　}\n　　```\n　　运行结果如下：\n　　![运行结果](https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153439356-1906667270.png)\n　　\n　　**存在的问题**\n　　\n　　\n　　在每次C++调用时都需要传递OC对象桥接为==void *==的指针，使用起来很不方便。\n　　\n　　## 方式二 by C++ IMPL\n　　**MyObject-C-Interface.h**\n　　\n　　```\n　　#ifndef MyObject_C_Interface_h__h\n　　#define MyObject_C_Interface_h__h\n\n　　class MyClassImpl\n　　{\n　　public:\n　　MyClassImpl ( void );\n　　~MyClassImpl( void );\n　　\n　　void init( void );\n　　int  doSomethingWith( void * aParameter );\n　　void logMyMessage( char * aCStr );\n　　\n　　private:\n　　void * self;\n　　};\n　　\n　　#endif /* MyObject_C_Interface_h__h */\n\n　　```\n　　需要注意的是，==MyClassImpl==的实现是放在OC中的\n　　**MyObject.h**\n　　\n　　```\n　　NS_ASSUME_NONNULL_BEGIN\n　　\n　　@interface MyObject : NSObject\n　　{\n　　int someVar;\n　　}\n　　\n　　- (int)  doSomethingWith:(void *) aParameter;\n　　- (void) logMyMessage:(char *) aCStr;\n\n\n　　@end\n　　\n　　NS_ASSUME_NONNULL_END\n　　```\n　　\n　　**MyObject.mm**\n　　\n　　```\n　　#include \"MyObject-C-Interface.h\"\n\n　　typedef void(^RetainSelfBlock)(void);\n　　\n　　@implementation MyObject\n　　{\n　　RetainSelfBlock _retainBlock;//通过这个block持有对象，造成循环引用，避免被释放\n　　}\n　　MyClassImpl::MyClassImpl( void )\n　　: self( NULL )\n　　{\n　　\n　　}\n　　\n　　MyClassImpl::~MyClassImpl( void )\n　　{\n　　[(__bridge id) self breakRetainCycly];\n　　}\n　　\n　　void MyClassImpl::init( void )\n　　{\n　　MyObject *object = [[MyObject alloc] init];\n　　object->_retainBlock = ^{//循环引用\n　　[object class];\n　　};\n　　\n　　self = (__bridge void *)object;\n　　\n　　NSLog(@\"%p\", self);\n　　}\n　　\n　　int MyClassImpl::doSomethingWith( void *aParameter )\n　　{\n　　NSLog(@\"%p\", self);\n　　return [(__bridge id)self doSomethingWith:aParameter];\n　　}\n　　\n　　void MyClassImpl::logMyMessage( char *aCStr )\n　　{\n　　[(__bridge id)self logMyMessage:aCStr];\n　　}\n　　\n　　- (int) doSomethingWith:(void *) aParameter\n　　{\n　　int result = 0;\n\n　　// ... some code to calculate the result\n　　\n　　return result;\n　　}\n　　\n　　- (void) logMyMessage:(char *) aCStr\n　　{\n　　NSLog( @\"%s\", aCStr );\n　　}\n\n　　//打破循环引用，释放对象\n　　- (void) breakRetainCycly\n　　{\n　　_retainBlock = nil;\n　　}\n\n　　- (void)dealloc\n　　{\n　　NSLog(@\"%s\", __func__);\n　　}\n　　@end\n　　```\n　　在==MyObject.mm==中需要注意的是，由于OC是使用ARC来进行内存管理的，C++不能够管理OC对象的生命周期。在默认的情况下，临时变量会在autorelease pool每一次pop后被释放，所以在oc实现中要想对象不被释放，那就需要循环引用来帮忙了。\n\n　　具体代码如下,在MyClassImpl初始化时，利用循环引用保证object不被释放，在MyClassImpl调用析构函数时，将block置空，打破循环引用，以此来释放oc对象\n　　\n　　```\n　　void MyClassImpl::init( void )\n　　{\n　　MyObject *object = [[MyObject alloc] init];\n　　object->_retainBlock = ^{//循环引用\n　　[object class];\n　　};\n　　\n　　self = (__bridge void *)object;\n　　\n　　NSLog(@\"%p\", self);\n　　}\n　　\n　　MyClassImpl::~MyClassImpl( void )\n　　{\n　　[(__bridge id) self breakRetainCycly];\n　　}\n　　\n　　//打破循环引用，释放对象\n　　- (void) breakRetainCycly\n　　{\n　　_retainBlock = nil;\n　　}\n\n　　```\n　　\n　　**MyCPPClass.hpp**\n　　\n　　```\n　　#ifndef MyCPPClass_hpp\n　　#define MyCPPClass_hpp\n\n　　#include <stdio.h>\n\n　　class MyClassImpl;\n　　\n　　class MyCPPClass\n　　{\n　　enum { cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING = 42 };\n　　public:\n　　MyCPPClass ( void );\n　　~MyCPPClass( void );\n　　\n　　void init( void );\n　　void doSomethingWithMyClass( void );\n　　\n　　private:\n　　MyClassImpl * _impl;\n　　int           _myValue;\n　　};\n　　\n　　\n　　#endif /* MyCPPClass_hpp */\n　　```\n　　\n　　**MyCPPClass.cpp**\n　　\n　　```\n　　#include \"MyCPPClass.hpp\"\n　　#include \"MyObject-C-Interface.h\"\n\n　　MyCPPClass::MyCPPClass( void )\n　　: _impl ( NULL )\n　　{   }\n　　\n　　void MyCPPClass::init( void )\n　　{\n　　_impl = new MyClassImpl();\n　　_impl->init();\n　　}\n　　\n　　MyCPPClass::~MyCPPClass( void )\n　　{\n　　if ( _impl ) { delete _impl; _impl = NULL; }\n　　}\n　　\n　　void MyCPPClass::doSomethingWithMyClass( void )\n　　{\n　　int result = _impl->doSomethingWith(&_myValue);\n　　if ( result == cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING )\n　　{\n　　_impl->logMyMessage(\"Hello, Arthur!\");\n　　}\n　　else\n　　{\n　　_impl->logMyMessage(\"Don't worry.\");\n　　}\n　　}\n　　```\n　　\n　　**main.mm**\n　　\n　　```\n　　#include \"MyCPPClass.hpp\"\n\n　　int main(int argc, const char * argv[]) {\n　　@autoreleasepool {\n　　MyCPPClass *temp = new MyCPPClass();\n　　temp->init();\n　　temp->doSomethingWithMyClass();\n　　delete temp;\n　　}\n　　return 0;\n　　}\n　　```\n　　**运行结果**\n　　![by c++ IMPL](https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153613056-820038660.png)\n　　\n　　# 总结\n　　第一种通过C语言的方式来调用，使用起来更复杂，所以建议使用C++的方式来实现。需要注意的问题是C++不能管理OC对象的释放，所以需要利用循环引用。\n　　\n　　你可以在这里下载[demo](https://github.com/WuKongCoo1/C-Invoke-OC/tree/master)\n　　\n　　参考：[https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function](https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function)\n","source":"_posts/C-中调用OC代码.md","raw":"---\ntitle: C++中调用OC代码\ndate: 2019-08-20 13:16:19\ntags:\ncategories:\n- [sundry]\n---\n# 前言\n\n　　最近项目中为了方便维护，底层统一使用C++编写。由于是项目是做屏幕共享sdk，所以只能底层的压缩、编解码使用C++，屏幕捕获部分Mac和win就自己实现了。那么问题就来了，因为是面向接口编程，所以项目的入口都是c++来写的，而屏幕捕获是需要oc部分的代码，就需要C++调用oc代码了。\n\n# 准备\n\n　　之前只做过OC调动C++，于是Google了一下，在Stack Overflow上找到了这个[回答](https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function)。要看具体描述的可以去链接看看，实现思路一共有两种，我在这里大概描述一下。第一种，由于C++是不能直接调用OC的，所以需要通过C语言作为中间层，即C++调用C，C调用OC，这样就达到了C++调用OC的目的。第二种OC是可以调用C++的，通过在外部声名C++类，然后类具体实现放在OC类中，这样C++类就能够调用OC类了，其他需要调用OC的类，只需要调用外部声名的类即可。\n\n# 实现\n\n具体的实现方式有两种，第一种是C语言方法接收oc对象指针和参数，然后把指针桥接为具体的oc对象。第二种是用C++进行包装，先声名一个C++类，这里称为A。然后在OC类中，这里称为B，对A进行实现，因为这个实现实在OC语言里的，所以在这里是可以直接调用OC代码的。接下来声名一个C++类C。类C通过持有类A来调用OC类B，即A（C++）->C（C++）->B(OC类)\n\n　　## 实现方式一 by C\n\n**MyObject-C-Interface.h**\n　　```\n　　int MyObjectDoSomethingWith (void *myObjectInstance, void *parameter);\n　　```\n　　\n**MyObject.h**\n　　```\n　　@interface MyObject : NSObject\n　　{\n　　int someVar;\n　　}\n　　\n\n　　- (int)doSomethingWith:(void *)aParameter;\n　　@end\n\n　　```\n　　**MyObject.mm**\n　　```\n　　@implementation MyObject\n　　\n　　int MyObjectDoSomethingWith (void *self, void *aParameter)\n　　{\n　　// 通过将self指针桥接为oc 对象来调用oc方法\n　　return [(__bridge id)self doSomethingWith:aParameter];\n　　}\n　　\n\n　　- (int) doSomethingWith:(void *) aParameter\n　　{\n　　//将void *指针强转为对应的类型\n　　int* param = (int *)aParameter;\n　　return *param / 2 ;\n　　}\n\n　　- (void)dealloc\n　　{\n　　NSLog(@\"%s\", __func__);\n　　}\n\n　　@end\n　　```\n　　**MyCPPClass.h**\n　　```\n　　class MyCPPClass {\n　　\n　　\n　　public:\n　　MyCPPClass();\n　　~MyCPPClass();\n　　int someMethod (void *objectiveCObject, void *aParameter);\n　　void *self;\n　　\n　　void setSelf(void *self);\n　　};\n　　\n　　```\n　　\n　　**MyCPPClass.cpp**\n　　\n　　```\n\n　　#include \"MyObject-C-Interface.h\"\n\n　　MyCPPClass::MyCPPClass()\n　　{\n　　\n　　}\n　　\n　　MyCPPClass::~MyCPPClass()\n　　{\n　　\n　　}\n　　\n　　\n　　int MyCPPClass::someMethod (void *objectiveCObject, void *aParameter)\n　　{\n　　// To invoke an Objective-C method from C++, use\n　　// the C trampoline function\n　　return MyObjectDoSomethingWith (objectiveCObject, aParameter);\n　　}\n　　\n　　void MyCPPClass::setSelf(void *aSelf)\n　　{\n　　self = aSelf;\n　　}\n　　\n　　```\n　　**main.mm**\n　　\n　　```\n\n　　#include \"MyCPPClass.hpp\"\n　　#import \"MyObject.h\"\n\n　　int main(int argc, const char * argv[]) {\n　　@autoreleasepool {\n　　// insert code here...\n　　NSLog(@\"Hello, World!\");\n　　MyObject *object = [[MyObject alloc] init];\n　　MyCPPClass *c = new MyCPPClass();\n　　c->setSelf((__bridge void *)object);\n　　int a = 12;\n　　int result = c->someMethod((__bridge void *)object, &a);\n　　NSLog(@\"%d\", result);\n　　}\n　　return 0;\n　　}\n　　```\n　　运行结果如下：\n　　![运行结果](https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153439356-1906667270.png)\n　　\n　　**存在的问题**\n　　\n　　\n　　在每次C++调用时都需要传递OC对象桥接为==void *==的指针，使用起来很不方便。\n　　\n　　## 方式二 by C++ IMPL\n　　**MyObject-C-Interface.h**\n　　\n　　```\n　　#ifndef MyObject_C_Interface_h__h\n　　#define MyObject_C_Interface_h__h\n\n　　class MyClassImpl\n　　{\n　　public:\n　　MyClassImpl ( void );\n　　~MyClassImpl( void );\n　　\n　　void init( void );\n　　int  doSomethingWith( void * aParameter );\n　　void logMyMessage( char * aCStr );\n　　\n　　private:\n　　void * self;\n　　};\n　　\n　　#endif /* MyObject_C_Interface_h__h */\n\n　　```\n　　需要注意的是，==MyClassImpl==的实现是放在OC中的\n　　**MyObject.h**\n　　\n　　```\n　　NS_ASSUME_NONNULL_BEGIN\n　　\n　　@interface MyObject : NSObject\n　　{\n　　int someVar;\n　　}\n　　\n　　- (int)  doSomethingWith:(void *) aParameter;\n　　- (void) logMyMessage:(char *) aCStr;\n\n\n　　@end\n　　\n　　NS_ASSUME_NONNULL_END\n　　```\n　　\n　　**MyObject.mm**\n　　\n　　```\n　　#include \"MyObject-C-Interface.h\"\n\n　　typedef void(^RetainSelfBlock)(void);\n　　\n　　@implementation MyObject\n　　{\n　　RetainSelfBlock _retainBlock;//通过这个block持有对象，造成循环引用，避免被释放\n　　}\n　　MyClassImpl::MyClassImpl( void )\n　　: self( NULL )\n　　{\n　　\n　　}\n　　\n　　MyClassImpl::~MyClassImpl( void )\n　　{\n　　[(__bridge id) self breakRetainCycly];\n　　}\n　　\n　　void MyClassImpl::init( void )\n　　{\n　　MyObject *object = [[MyObject alloc] init];\n　　object->_retainBlock = ^{//循环引用\n　　[object class];\n　　};\n　　\n　　self = (__bridge void *)object;\n　　\n　　NSLog(@\"%p\", self);\n　　}\n　　\n　　int MyClassImpl::doSomethingWith( void *aParameter )\n　　{\n　　NSLog(@\"%p\", self);\n　　return [(__bridge id)self doSomethingWith:aParameter];\n　　}\n　　\n　　void MyClassImpl::logMyMessage( char *aCStr )\n　　{\n　　[(__bridge id)self logMyMessage:aCStr];\n　　}\n　　\n　　- (int) doSomethingWith:(void *) aParameter\n　　{\n　　int result = 0;\n\n　　// ... some code to calculate the result\n　　\n　　return result;\n　　}\n　　\n　　- (void) logMyMessage:(char *) aCStr\n　　{\n　　NSLog( @\"%s\", aCStr );\n　　}\n\n　　//打破循环引用，释放对象\n　　- (void) breakRetainCycly\n　　{\n　　_retainBlock = nil;\n　　}\n\n　　- (void)dealloc\n　　{\n　　NSLog(@\"%s\", __func__);\n　　}\n　　@end\n　　```\n　　在==MyObject.mm==中需要注意的是，由于OC是使用ARC来进行内存管理的，C++不能够管理OC对象的生命周期。在默认的情况下，临时变量会在autorelease pool每一次pop后被释放，所以在oc实现中要想对象不被释放，那就需要循环引用来帮忙了。\n\n　　具体代码如下,在MyClassImpl初始化时，利用循环引用保证object不被释放，在MyClassImpl调用析构函数时，将block置空，打破循环引用，以此来释放oc对象\n　　\n　　```\n　　void MyClassImpl::init( void )\n　　{\n　　MyObject *object = [[MyObject alloc] init];\n　　object->_retainBlock = ^{//循环引用\n　　[object class];\n　　};\n　　\n　　self = (__bridge void *)object;\n　　\n　　NSLog(@\"%p\", self);\n　　}\n　　\n　　MyClassImpl::~MyClassImpl( void )\n　　{\n　　[(__bridge id) self breakRetainCycly];\n　　}\n　　\n　　//打破循环引用，释放对象\n　　- (void) breakRetainCycly\n　　{\n　　_retainBlock = nil;\n　　}\n\n　　```\n　　\n　　**MyCPPClass.hpp**\n　　\n　　```\n　　#ifndef MyCPPClass_hpp\n　　#define MyCPPClass_hpp\n\n　　#include <stdio.h>\n\n　　class MyClassImpl;\n　　\n　　class MyCPPClass\n　　{\n　　enum { cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING = 42 };\n　　public:\n　　MyCPPClass ( void );\n　　~MyCPPClass( void );\n　　\n　　void init( void );\n　　void doSomethingWithMyClass( void );\n　　\n　　private:\n　　MyClassImpl * _impl;\n　　int           _myValue;\n　　};\n　　\n　　\n　　#endif /* MyCPPClass_hpp */\n　　```\n　　\n　　**MyCPPClass.cpp**\n　　\n　　```\n　　#include \"MyCPPClass.hpp\"\n　　#include \"MyObject-C-Interface.h\"\n\n　　MyCPPClass::MyCPPClass( void )\n　　: _impl ( NULL )\n　　{   }\n　　\n　　void MyCPPClass::init( void )\n　　{\n　　_impl = new MyClassImpl();\n　　_impl->init();\n　　}\n　　\n　　MyCPPClass::~MyCPPClass( void )\n　　{\n　　if ( _impl ) { delete _impl; _impl = NULL; }\n　　}\n　　\n　　void MyCPPClass::doSomethingWithMyClass( void )\n　　{\n　　int result = _impl->doSomethingWith(&_myValue);\n　　if ( result == cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING )\n　　{\n　　_impl->logMyMessage(\"Hello, Arthur!\");\n　　}\n　　else\n　　{\n　　_impl->logMyMessage(\"Don't worry.\");\n　　}\n　　}\n　　```\n　　\n　　**main.mm**\n　　\n　　```\n　　#include \"MyCPPClass.hpp\"\n\n　　int main(int argc, const char * argv[]) {\n　　@autoreleasepool {\n　　MyCPPClass *temp = new MyCPPClass();\n　　temp->init();\n　　temp->doSomethingWithMyClass();\n　　delete temp;\n　　}\n　　return 0;\n　　}\n　　```\n　　**运行结果**\n　　![by c++ IMPL](https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153613056-820038660.png)\n　　\n　　# 总结\n　　第一种通过C语言的方式来调用，使用起来更复杂，所以建议使用C++的方式来实现。需要注意的问题是C++不能管理OC对象的释放，所以需要利用循环引用。\n　　\n　　你可以在这里下载[demo](https://github.com/WuKongCoo1/C-Invoke-OC/tree/master)\n　　\n　　参考：[https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function](https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function)\n","slug":"C-中调用OC代码","published":1,"updated":"2019-08-20T05:27:31.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyuki0002oqs642n9wcnq","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>　　最近项目中为了方便维护，底层统一使用C++编写。由于是项目是做屏幕共享sdk，所以只能底层的压缩、编解码使用C++，屏幕捕获部分Mac和win就自己实现了。那么问题就来了，因为是面向接口编程，所以项目的入口都是c++来写的，而屏幕捕获是需要oc部分的代码，就需要C++调用oc代码了。</p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><p>　　之前只做过OC调动C++，于是Google了一下，在Stack Overflow上找到了这个<a href=\"https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function\" target=\"_blank\" rel=\"noopener\">回答</a>。要看具体描述的可以去链接看看，实现思路一共有两种，我在这里大概描述一下。第一种，由于C++是不能直接调用OC的，所以需要通过C语言作为中间层，即C++调用C，C调用OC，这样就达到了C++调用OC的目的。第二种OC是可以调用C++的，通过在外部声名C++类，然后类具体实现放在OC类中，这样C++类就能够调用OC类了，其他需要调用OC的类，只需要调用外部声名的类即可。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>具体的实现方式有两种，第一种是C语言方法接收oc对象指针和参数，然后把指针桥接为具体的oc对象。第二种是用C++进行包装，先声名一个C++类，这里称为A。然后在OC类中，这里称为B，对A进行实现，因为这个实现实在OC语言里的，所以在这里是可以直接调用OC代码的。接下来声名一个C++类C。类C通过持有类A来调用OC类B，即A（C++）-&gt;C（C++）-&gt;B(OC类)</p>\n<p>　　## 实现方式一 by C</p>\n<p><strong>MyObject-C-Interface.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　int MyObjectDoSomethingWith (void *myObjectInstance, void *parameter);</span><br></pre></td></tr></table></figure></p>\n<p>　　<br><strong>MyObject.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　@interface MyObject : NSObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int someVar;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (int)doSomethingWith:(void *)aParameter;</span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>MyObject.mm</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　@implementation MyObject</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyObjectDoSomethingWith (void *self, void *aParameter)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　// 通过将self指针桥接为oc 对象来调用oc方法</span><br><span class=\"line\">　　return [(__bridge id)self doSomethingWith:aParameter];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (int) doSomethingWith:(void *) aParameter</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　//将void *指针强转为对应的类型</span><br><span class=\"line\">　　int* param = (int *)aParameter;</span><br><span class=\"line\">　　return *param / 2 ;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (void)dealloc</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>MyCPPClass.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　class MyCPPClass &#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyCPPClass();</span><br><span class=\"line\">　　~MyCPPClass();</span><br><span class=\"line\">　　int someMethod (void *objectiveCObject, void *aParameter);</span><br><span class=\"line\">　　void *self;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void setSelf(void *self);</span><br><span class=\"line\">　　&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.cpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　MyCPPClass::MyCPPClass()</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyCPPClass::~MyCPPClass()</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyCPPClass::someMethod (void *objectiveCObject, void *aParameter)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　// To invoke an Objective-C method from C++, use</span><br><span class=\"line\">　　// the C trampoline function</span><br><span class=\"line\">　　return MyObjectDoSomethingWith (objectiveCObject, aParameter);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::setSelf(void *aSelf)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　self = aSelf;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>main.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\">　　#import &quot;MyObject.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">　　@autoreleasepool &#123;</span><br><span class=\"line\">　　// insert code here...</span><br><span class=\"line\">　　NSLog(@&quot;Hello, World!&quot;);</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　MyCPPClass *c = new MyCPPClass();</span><br><span class=\"line\">　　c-&gt;setSelf((__bridge void *)object);</span><br><span class=\"line\">　　int a = 12;</span><br><span class=\"line\">　　int result = c-&gt;someMethod((__bridge void *)object, &amp;a);</span><br><span class=\"line\">　　NSLog(@&quot;%d&quot;, result);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return 0;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　运行结果如下：<br>　　<img src=\"https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153439356-1906667270.png\" alt=\"运行结果\"><br>　　<br>　　<strong>存在的问题</strong><br>　　<br>　　<br>　　在每次C++调用时都需要传递OC对象桥接为==void <em>==的指针，使用起来很不方便。<br>　　<br>　　## 方式二 by C++ IMPL<br>　　*</em>MyObject-C-Interface.h**<br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#ifndef MyObject_C_Interface_h__h</span><br><span class=\"line\">　　#define MyObject_C_Interface_h__h</span><br><span class=\"line\"></span><br><span class=\"line\">　　class MyClassImpl</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyClassImpl ( void );</span><br><span class=\"line\">　　~MyClassImpl( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void init( void );</span><br><span class=\"line\">　　int  doSomethingWith( void * aParameter );</span><br><span class=\"line\">　　void logMyMessage( char * aCStr );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　private:</span><br><span class=\"line\">　　void * self;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　#endif /* MyObject_C_Interface_h__h */</span><br></pre></td></tr></table></figure></p>\n<p>　　需要注意的是，==MyClassImpl==的实现是放在OC中的<br>　　<strong>MyObject.h</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　@interface MyObject : NSObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int someVar;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (int)  doSomethingWith:(void *) aParameter;</span><br><span class=\"line\">　　- (void) logMyMessage:(char *) aCStr;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　@end</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyObject.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　typedef void(^RetainSelfBlock)(void);</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　@implementation MyObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　RetainSelfBlock _retainBlock;//通过这个block持有对象，造成循环引用，避免被释放</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　MyClassImpl::MyClassImpl( void )</span><br><span class=\"line\">　　: self( NULL )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyClassImpl::~MyClassImpl( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id) self breakRetainCycly];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyClassImpl::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　object-&gt;_retainBlock = ^&#123;//循环引用</span><br><span class=\"line\">　　[object class];</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　self = (__bridge void *)object;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyClassImpl::doSomethingWith( void *aParameter )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　return [(__bridge id)self doSomethingWith:aParameter];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyClassImpl::logMyMessage( char *aCStr )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id)self logMyMessage:aCStr];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (int) doSomethingWith:(void *) aParameter</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int result = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">　　// ... some code to calculate the result</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　return result;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (void) logMyMessage:(char *) aCStr</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog( @&quot;%s&quot;, aCStr );</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　//打破循环引用，释放对象</span><br><span class=\"line\">　　- (void) breakRetainCycly</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_retainBlock = nil;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (void)dealloc</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　在==MyObject.mm==中需要注意的是，由于OC是使用ARC来进行内存管理的，C++不能够管理OC对象的生命周期。在默认的情况下，临时变量会在autorelease pool每一次pop后被释放，所以在oc实现中要想对象不被释放，那就需要循环引用来帮忙了。</p>\n<p>　　具体代码如下,在MyClassImpl初始化时，利用循环引用保证object不被释放，在MyClassImpl调用析构函数时，将block置空，打破循环引用，以此来释放oc对象<br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　void MyClassImpl::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　object-&gt;_retainBlock = ^&#123;//循环引用</span><br><span class=\"line\">　　[object class];</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　self = (__bridge void *)object;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyClassImpl::~MyClassImpl( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id) self breakRetainCycly];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　//打破循环引用，释放对象</span><br><span class=\"line\">　　- (void) breakRetainCycly</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_retainBlock = nil;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.hpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#ifndef MyCPPClass_hpp</span><br><span class=\"line\">　　#define MyCPPClass_hpp</span><br><span class=\"line\"></span><br><span class=\"line\">　　#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">　　class MyClassImpl;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　class MyCPPClass</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　enum &#123; cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING = 42 &#125;;</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyCPPClass ( void );</span><br><span class=\"line\">　　~MyCPPClass( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void init( void );</span><br><span class=\"line\">　　void doSomethingWithMyClass( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　private:</span><br><span class=\"line\">　　MyClassImpl * _impl;</span><br><span class=\"line\">　　int           _myValue;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　#endif /* MyCPPClass_hpp */</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.cpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　MyCPPClass::MyCPPClass( void )</span><br><span class=\"line\">　　: _impl ( NULL )</span><br><span class=\"line\">　　&#123;   &#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl = new MyClassImpl();</span><br><span class=\"line\">　　_impl-&gt;init();</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyCPPClass::~MyCPPClass( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　if ( _impl ) &#123; delete _impl; _impl = NULL; &#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::doSomethingWithMyClass( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int result = _impl-&gt;doSomethingWith(&amp;_myValue);</span><br><span class=\"line\">　　if ( result == cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl-&gt;logMyMessage(&quot;Hello, Arthur!&quot;);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　else</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl-&gt;logMyMessage(&quot;Don&apos;t worry.&quot;);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>main.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">　　@autoreleasepool &#123;</span><br><span class=\"line\">　　MyCPPClass *temp = new MyCPPClass();</span><br><span class=\"line\">　　temp-&gt;init();</span><br><span class=\"line\">　　temp-&gt;doSomethingWithMyClass();</span><br><span class=\"line\">　　delete temp;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return 0;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>运行结果</strong><br>　　<img src=\"https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153613056-820038660.png\" alt=\"by c++ IMPL\"><br>　　<br>　　# 总结<br>　　第一种通过C语言的方式来调用，使用起来更复杂，所以建议使用C++的方式来实现。需要注意的问题是C++不能管理OC对象的释放，所以需要利用循环引用。<br>　　<br>　　你可以在这里下载<a href=\"https://github.com/WuKongCoo1/C-Invoke-OC/tree/master\" target=\"_blank\" rel=\"noopener\">demo</a><br>　　<br>　　参考：<a href=\"https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>　　最近项目中为了方便维护，底层统一使用C++编写。由于是项目是做屏幕共享sdk，所以只能底层的压缩、编解码使用C++，屏幕捕获部分Mac和win就自己实现了。那么问题就来了，因为是面向接口编程，所以项目的入口都是c++来写的，而屏幕捕获是需要oc部分的代码，就需要C++调用oc代码了。</p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><p>　　之前只做过OC调动C++，于是Google了一下，在Stack Overflow上找到了这个<a href=\"https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function\" target=\"_blank\" rel=\"noopener\">回答</a>。要看具体描述的可以去链接看看，实现思路一共有两种，我在这里大概描述一下。第一种，由于C++是不能直接调用OC的，所以需要通过C语言作为中间层，即C++调用C，C调用OC，这样就达到了C++调用OC的目的。第二种OC是可以调用C++的，通过在外部声名C++类，然后类具体实现放在OC类中，这样C++类就能够调用OC类了，其他需要调用OC的类，只需要调用外部声名的类即可。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>具体的实现方式有两种，第一种是C语言方法接收oc对象指针和参数，然后把指针桥接为具体的oc对象。第二种是用C++进行包装，先声名一个C++类，这里称为A。然后在OC类中，这里称为B，对A进行实现，因为这个实现实在OC语言里的，所以在这里是可以直接调用OC代码的。接下来声名一个C++类C。类C通过持有类A来调用OC类B，即A（C++）-&gt;C（C++）-&gt;B(OC类)</p>\n<p>　　## 实现方式一 by C</p>\n<p><strong>MyObject-C-Interface.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　int MyObjectDoSomethingWith (void *myObjectInstance, void *parameter);</span><br></pre></td></tr></table></figure></p>\n<p>　　<br><strong>MyObject.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　@interface MyObject : NSObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int someVar;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (int)doSomethingWith:(void *)aParameter;</span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>MyObject.mm</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　@implementation MyObject</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyObjectDoSomethingWith (void *self, void *aParameter)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　// 通过将self指针桥接为oc 对象来调用oc方法</span><br><span class=\"line\">　　return [(__bridge id)self doSomethingWith:aParameter];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (int) doSomethingWith:(void *) aParameter</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　//将void *指针强转为对应的类型</span><br><span class=\"line\">　　int* param = (int *)aParameter;</span><br><span class=\"line\">　　return *param / 2 ;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (void)dealloc</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>MyCPPClass.h</strong><br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　class MyCPPClass &#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyCPPClass();</span><br><span class=\"line\">　　~MyCPPClass();</span><br><span class=\"line\">　　int someMethod (void *objectiveCObject, void *aParameter);</span><br><span class=\"line\">　　void *self;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void setSelf(void *self);</span><br><span class=\"line\">　　&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.cpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　MyCPPClass::MyCPPClass()</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyCPPClass::~MyCPPClass()</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyCPPClass::someMethod (void *objectiveCObject, void *aParameter)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　// To invoke an Objective-C method from C++, use</span><br><span class=\"line\">　　// the C trampoline function</span><br><span class=\"line\">　　return MyObjectDoSomethingWith (objectiveCObject, aParameter);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::setSelf(void *aSelf)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　self = aSelf;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>main.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\">　　#import &quot;MyObject.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">　　@autoreleasepool &#123;</span><br><span class=\"line\">　　// insert code here...</span><br><span class=\"line\">　　NSLog(@&quot;Hello, World!&quot;);</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　MyCPPClass *c = new MyCPPClass();</span><br><span class=\"line\">　　c-&gt;setSelf((__bridge void *)object);</span><br><span class=\"line\">　　int a = 12;</span><br><span class=\"line\">　　int result = c-&gt;someMethod((__bridge void *)object, &amp;a);</span><br><span class=\"line\">　　NSLog(@&quot;%d&quot;, result);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return 0;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　运行结果如下：<br>　　<img src=\"https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153439356-1906667270.png\" alt=\"运行结果\"><br>　　<br>　　<strong>存在的问题</strong><br>　　<br>　　<br>　　在每次C++调用时都需要传递OC对象桥接为==void <em>==的指针，使用起来很不方便。<br>　　<br>　　## 方式二 by C++ IMPL<br>　　*</em>MyObject-C-Interface.h**<br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#ifndef MyObject_C_Interface_h__h</span><br><span class=\"line\">　　#define MyObject_C_Interface_h__h</span><br><span class=\"line\"></span><br><span class=\"line\">　　class MyClassImpl</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyClassImpl ( void );</span><br><span class=\"line\">　　~MyClassImpl( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void init( void );</span><br><span class=\"line\">　　int  doSomethingWith( void * aParameter );</span><br><span class=\"line\">　　void logMyMessage( char * aCStr );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　private:</span><br><span class=\"line\">　　void * self;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　#endif /* MyObject_C_Interface_h__h */</span><br></pre></td></tr></table></figure></p>\n<p>　　需要注意的是，==MyClassImpl==的实现是放在OC中的<br>　　<strong>MyObject.h</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　@interface MyObject : NSObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int someVar;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (int)  doSomethingWith:(void *) aParameter;</span><br><span class=\"line\">　　- (void) logMyMessage:(char *) aCStr;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">　　@end</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyObject.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　typedef void(^RetainSelfBlock)(void);</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　@implementation MyObject</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　RetainSelfBlock _retainBlock;//通过这个block持有对象，造成循环引用，避免被释放</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　MyClassImpl::MyClassImpl( void )</span><br><span class=\"line\">　　: self( NULL )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyClassImpl::~MyClassImpl( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id) self breakRetainCycly];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyClassImpl::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　object-&gt;_retainBlock = ^&#123;//循环引用</span><br><span class=\"line\">　　[object class];</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　self = (__bridge void *)object;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　int MyClassImpl::doSomethingWith( void *aParameter )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　return [(__bridge id)self doSomethingWith:aParameter];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyClassImpl::logMyMessage( char *aCStr )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id)self logMyMessage:aCStr];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (int) doSomethingWith:(void *) aParameter</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int result = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">　　// ... some code to calculate the result</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　return result;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　- (void) logMyMessage:(char *) aCStr</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog( @&quot;%s&quot;, aCStr );</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　//打破循环引用，释放对象</span><br><span class=\"line\">　　- (void) breakRetainCycly</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_retainBlock = nil;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　- (void)dealloc</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　NSLog(@&quot;%s&quot;, __func__);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　@end</span><br></pre></td></tr></table></figure></p>\n<p>　　在==MyObject.mm==中需要注意的是，由于OC是使用ARC来进行内存管理的，C++不能够管理OC对象的生命周期。在默认的情况下，临时变量会在autorelease pool每一次pop后被释放，所以在oc实现中要想对象不被释放，那就需要循环引用来帮忙了。</p>\n<p>　　具体代码如下,在MyClassImpl初始化时，利用循环引用保证object不被释放，在MyClassImpl调用析构函数时，将block置空，打破循环引用，以此来释放oc对象<br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　void MyClassImpl::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　MyObject *object = [[MyObject alloc] init];</span><br><span class=\"line\">　　object-&gt;_retainBlock = ^&#123;//循环引用</span><br><span class=\"line\">　　[object class];</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　self = (__bridge void *)object;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　NSLog(@&quot;%p&quot;, self);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyClassImpl::~MyClassImpl( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　[(__bridge id) self breakRetainCycly];</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　//打破循环引用，释放对象</span><br><span class=\"line\">　　- (void) breakRetainCycly</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_retainBlock = nil;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.hpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#ifndef MyCPPClass_hpp</span><br><span class=\"line\">　　#define MyCPPClass_hpp</span><br><span class=\"line\"></span><br><span class=\"line\">　　#include &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">　　class MyClassImpl;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　class MyCPPClass</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　enum &#123; cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING = 42 &#125;;</span><br><span class=\"line\">　　public:</span><br><span class=\"line\">　　MyCPPClass ( void );</span><br><span class=\"line\">　　~MyCPPClass( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void init( void );</span><br><span class=\"line\">　　void doSomethingWithMyClass( void );</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　private:</span><br><span class=\"line\">　　MyClassImpl * _impl;</span><br><span class=\"line\">　　int           _myValue;</span><br><span class=\"line\">　　&#125;;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　#endif /* MyCPPClass_hpp */</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>MyCPPClass.cpp</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\">　　#include &quot;MyObject-C-Interface.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　MyCPPClass::MyCPPClass( void )</span><br><span class=\"line\">　　: _impl ( NULL )</span><br><span class=\"line\">　　&#123;   &#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::init( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl = new MyClassImpl();</span><br><span class=\"line\">　　_impl-&gt;init();</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　MyCPPClass::~MyCPPClass( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　if ( _impl ) &#123; delete _impl; _impl = NULL; &#125;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　</span><br><span class=\"line\">　　void MyCPPClass::doSomethingWithMyClass( void )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　int result = _impl-&gt;doSomethingWith(&amp;_myValue);</span><br><span class=\"line\">　　if ( result == cANSWER_TO_LIFE_THE_UNIVERSE_AND_EVERYTHING )</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl-&gt;logMyMessage(&quot;Hello, Arthur!&quot;);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　else</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　_impl-&gt;logMyMessage(&quot;Don&apos;t worry.&quot;);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<br>　　<strong>main.mm</strong><br>　　<br>　　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　#include &quot;MyCPPClass.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">　　int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">　　@autoreleasepool &#123;</span><br><span class=\"line\">　　MyCPPClass *temp = new MyCPPClass();</span><br><span class=\"line\">　　temp-&gt;init();</span><br><span class=\"line\">　　temp-&gt;doSomethingWithMyClass();</span><br><span class=\"line\">　　delete temp;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">　　return 0;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure></p>\n<p>　　<strong>运行结果</strong><br>　　<img src=\"https://img2018.cnblogs.com/blog/552616/201906/552616-20190626153613056-820038660.png\" alt=\"by c++ IMPL\"><br>　　<br>　　# 总结<br>　　第一种通过C语言的方式来调用，使用起来更复杂，所以建议使用C++的方式来实现。需要注意的问题是C++不能管理OC对象的释放，所以需要利用循环引用。<br>　　<br>　　你可以在这里下载<a href=\"https://github.com/WuKongCoo1/C-Invoke-OC/tree/master\" target=\"_blank\" rel=\"noopener\">demo</a><br>　　<br>　　参考：<a href=\"https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/1061005/calling-objective-c-method-from-c-member-function</a></p>\n"},{"title":"C、C++格式化字符串","date":"2019-09-09T18:05:44.000Z","typora-root-url":"../../source","_content":"\n# 引言\n\n在C和C++开发中，我们经常会用到printf来进行字符串的格式化，例如`printf(\"format string %d, %d\", 1, 2);`，这样的格式化只是用于打印调试信息。printf函数实现的是接收可变参数，然后解析格式化的字符串，最后输出到控制台。那么问题来了，当我们需要实现一个函数，根据传入的可变参数来生成格式化的字符串，应该怎么办呢？\n\n# 正文\n\n## 可变参数\n\n首先来一个可变参数使用示例，`testVariadic`方法接收int行的可变参数，并以可变参数为-1表示结束。va_list用于遍历可变参数，`va_start`方法接收两个参数，第一个为`va_list`，第二个为可变参数前一个参数，下面的例子里该参数为a。\n\n```c\n/**\n 下面是 <stdarg.h> 里面重要的几个宏定义如下：\n typedef char* va_list;\n void va_start ( va_list ap, prev_param ); // ANSI version\n type va_arg ( va_list ap, type );\n void va_end ( va_list ap );\n va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。\n <Step 1> 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；\n <Step 2> 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数；\n <Step 3> 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；\n <Step 4> 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。\n */\n//-1表示可变参数结束\nvoid receiveVariadic(int a, ...) {\n    va_list list;\n    va_start(list, a);\n    int arg = a;\n    while (arg != -1) {\n        arg = va_arg(list, int);\n        printf(\"%d \", arg);\n    }\n    printf(\"\\n\");\n    va_end(list);\n}\n\n//test\nvoid testVari()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    //-1表示可变参数结束\n    receiveVariadic(1, 2, 3, 4, 5, 6, -1);\n}\n```\n\n运行结果\n\n```\n------testVari------\n2 3 4 5 6 -1 \n```\n\n## 格式化字符串\n\n好了，我们已经介绍了怎样实现一个接收可变参数的C函数，接下来介绍根据接收的可变参数来格式化字符串。这里介绍两种方式，第一种是利用宏定义，第二种通过函数的方式来实现。\n\n### 通过宏定义的方式\n\nen…让咱们先来看看第一个版本的宏，这个宏定义对于不熟悉宏的人来说可能看着有点费劲，不过不要怕，稍后会做解释，代码如下：\n\n```c\n#define myFormatStringByMacro_WithoutReturn(format, ...) \\\ndo { \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    printf(\"%s\", buf); \\\n    free(buf); \\\n} while(0)\n\n```\n\n#### 宏基础知识\n\n首先需要介绍宏用到的知识：`\\`, 这个`\\`的作用是可换行定义宏，毕竟如果一行很长的宏可读性很差，使用方式在换行时加上`\\`即可。第二个是介绍`(format, ...)`，这里的`...`是预定义的宏，用于接收可变参数，就像是`printf`函数一样。接着介绍`##__VA_ARGS__`，同样的`__VA_ARGS__`也是预定义的宏，表示接收到的`...`传入的可变参数。`##`的作用是用来处理未传入可变参数的情况，当没有传入可变参数的时候，编译器或通过优化将`snprintf(NULL, 0, format, ##__VA_ARGS__);`优化为`snprintf(NULL, 0, format);`。你可以理解为没有可变参数时，`##`前的逗号`,`与`__VA_ARGS__`都被“干掉了”。\n\n你一定会觉得困惑，为什么要写`do-while`语句呢？这是为了宏的健壮性，如果使用宏的人像下面这样使用的话，就会出问题\n\n```c\n#define testMarco(a, b) \\\nint _a = a + 1; \\\nint _b = b + 1; \\\nprintf(\"\\n%d\", _a + _b); \\\n\nvoid test()\n{\n    if (1 > 0)\n        testMarco(1, 2);\n}\n```\n\n上面的代码连编译都不会通过, 会报错如下:\n\n![](/images/macro_1.png)\n\n如果手动展开这个宏的话，会变成这个样子，问题就显而易见了。但是如果`if`语句加上了`{}`的话，就不会有问题，可以看出规范写法是多么的重要🐶（皮一下很开心）。\n\n```c\nvoid test()\n{\n    if (1 > 0)\n        int _a = 1 + 1; int _b = 2 + 1; printf(\"\\n%d\", _a + _b);;\n}\n```\n\n加上`do-while`以后就不一样，加上do-while后的代码如下：\n\n```c\n#define testMarco(a, b) \\\ndo { \\\nint _a = a + 1; \\\nint _b = b + 1; \\\nprintf(\"\\n%d\", _a + _b); \\\n} while(0)\n\nvoid test()\n{\n    if (1 > 0)\n        testMarco(1, 2);\n}\n\n\n```\n\n预处理之后代码如下：\n\n```c\n//展开后的代码 \nvoid test()\n{\n    if (1 > 0)\n        do { int _a = 1 + 1; int _b = 2 + 1; printf(\"\\n%d\", _a + _b); } while(0);\n}\n```\n\n好了，宏的基础知识就介绍这么多了，接下来进入正题。\n\n#### 代码解析\n\n为了方便阅读，原谅我在这里再贴一遍宏定义的代码：\n\n```c\n#define myFormatStringByMacro_WithoutReturn(format, ...) \\\ndo { \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    printf(\"%s\", buf); \\\n    free(buf); \\\n} while(0)\n```\n\n首先，介绍一下`snprintf()`函数，此函数的定义如下：\n\n```c\n/**\n \n @param __str 接收格式化结果的指针\n @param __size 接收的size\n @param __format 格式化的字符串\n @param ... 可变参数\n @return 返回格式化后实际上写入的大小a，a <= __size\n */\nint     snprintf(char * __restrict __str, size_t __size, const char * __restrict __format, ...) __printflike(3, 4);\n```\n\n为了方便理解，使用方式是这个样子的：\n\n```c\nvoid testSnprintf()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char des[50];\n    int size = snprintf(des, 50, \"less length %d\", 50);\n    printf(\"size:%d\\n\", size);\n}\n```\n\n运行结果：\n\n```\n------testSnprintf------\nsize:14\n```\n\n`snprintf`函数还有一个用法是`__str`和`__size`分别传入NULL和0，返回值会是格式化字符串的实际长度，可以通过这个方式来获取正确的格式化size，从而避免malloc多余的空间，造成空间浪费。同时返回的size是不包含结束符`\\0`的，所以真正写入要buffer时，需要对size + 1。\n\n相信通过我的解释，你一定能看懂上面这段代码了吧。哦，对了malloc的代码一定要记得free（敲重点）。\n\n到了这里，如果细心思考的同学一定会问？这个宏根本没有实际用途好不好，我要的是能够把格式化的字符串作为返回值返回的，仅仅打印直接用`printf`不就好了。其实，这样的宏还是有作用的，比如说当你要记录日志时，你可以像这样使用：\n\n```c\n#define Log_Debug(format, ...) \\\ndo { \\\nint size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\nsize++; \\\nchar *buf = (char *)malloc(size); \\\nsnprintf(buf, size, format, ##__VA_ARGS__); \\\ndoLog(buf); \\\nfree(buf); \\\n} while(0)\n```\n\n要将结果字符串返回的话，需要用到GNU C的赋值扩展，使用方式如下:\n\n```c\nint a = ({\n        int b = 2;\n        int c = 4;\n        b + c;\n    });\n```\n\n这段代码变量a最终值会是6。利用gnu这个扩展，将之前的宏改造一下就能实现我们的需求，改造完成后是这个样子的：\n\n```c\n#define myFormatStringByMacro_ReturnFormatString(format, ...) \\\n({ \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    buf; \\\n});\n```\n\n调用宏的代码：\n\n```c\nvoid testByMacro1()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *a = myFormatStringByMacro_ReturnFormatString(\"format by macro, %d %s\", 123, \"well done\");\n    printf(\"%s\\n\", a);\n    free(a);\n}\n```\n\n原谅我的啰嗦，malloc开辟的空间一定要记得free。运行结果：\n\n```c\n------testByMacro1------\nformat by macro, 123 well done\n```\n\n至此利用宏的方式就介绍完了。\n\n### 通过函数的方式\n\n老规矩先上代码\n\n```c\nchar *myFormatStringByFun(char *format, ...)\n{\n    va_list list;\n    //1. 先获取格式化后字符串的长度\n    va_start(list, format);\n    int size = vsnprintf(NULL, 0, format, list);\n    va_end(list);\n    if(size <= 0) {\n        return NULL;\n    }\n    size++;\n    \n    //2. 复位va_list，将格式化字符串写入到buf\n    va_start(list, format);\n    char *buf = (char *)malloc(size);\n    vsnprintf(buf, size, format, list);\n    va_end(list);\n    return buf;\n}\n```\n\n这里利用的是`vsnprintf`函数，此函数的定义在`stdio.h`中的定义如下：\n\n```c\n/**\n\n @param __str 目标字符串\n @param __size 要赋值的大小\n @param __format 格式化字符串\n @param va_list 可变参数列表\n @return 返回格式化后实际上写入的大小a，a <= __size\n */\nint     vsnprintf(char * __restrict __str, size_t __size, const char * __restrict __format, va_list) __printflike(3, 0);\n```\n\n`vsnprintf`的具体使用方式和之前介绍的`snprintf`是差不多的，这里就不再详细介绍了，不大明白的同学可以看看上面的介绍。哦，对了，这两个函数都是定义在stdio.h这个头文件下的\n\n接下来就是试一下我们封装的函数了\n\n```c\nvoid testByFun()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *b = myFormatStringByFun(\"format by fun %d %s\", 321, \"nice\");\n    printf(\"%s\\n\", b);\n}\n```\n\n运行结果：\n\n```c\n------testByFun------\nformat by fun 321 nice\n```\n\n格式化字符串的方法差不多介绍完了，不知道善于思考的你有没想到直接用宏定义来调用我们封装的函数呢？我就在这直接给出宏定义和使用方式了\n\n```c\n#define myFormatStringByFunQuick(format, ...) myFormatStringByFun(format, ##__VA_ARGS__);\nvoid testMyFormatStringByFunQuick() {\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *formatString = myFormatStringByFunQuick(\"amazing happen, %s\", \"cool\");\n    printf(\"%s\\n\", formatString);\n}\n```\n\n运行结果：\n\n```c\n------testMyFormatStringByFunQuick------\namazing happen\n```\n\n### C++版本\n\n对了，最初实现是用的C++版本，这里使用的是泛型，代码是这个样子的：\n\n```c++\ntemplate< typename... Args >\nstd::string string_sprintf( const char* format, Args... args ) {\n    int length = std::snprintf( nullptr, 0, format, args... );\n    assert( length >= 0 );\n    \n    char* buf = new char[length + 1];\n    std::snprintf( buf, length + 1, format, args... );\n    \n    std::string str( buf );\n    delete[] buf;\n    return str;\n}\n```\n\n其实和C语言版本的没什么差别，只是多了泛型的东西而已，相信聪明的你一定能看懂，看不懂的话，就去看看C++的泛型知识吧，哈哈哈。\n\n# 结语\n\n终于介绍完了，你可以在[这里](https://github.com/WuKongCoo1/DemoFormatString)下载代码。写博客是真的有点累人，不过对于最近被面试打击的我来说，写博客能够让我对知识理解的更加透彻，毕竟要自己认真思考后才能够写的明白（至少我觉得讲明白了，哈哈哈）。如果有什么说的不对的地方，还请指出，感谢你的阅读，thks。\n\n# 参考资料\n\n[std::string formatting like sprintf](https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf)\n\n[宏定义的黑魔法 - 宏菜鸟起飞手册](https://onevcat.com/2014/01/black-magic-in-macro/)\n\n[整理：C/C++可变参数，“## __VA_ARGS__”宏的介绍和使用](https://blog.csdn.net/bat67/article/details/77542165)","source":"_posts/C、CPlusPlus格式化字符串.md","raw":"---\ntitle: C、C++格式化字符串\ndate: 2019-09-09 18:05:44\ntags:\ncategories:\n- [sundry]\ntypora-root-url: ../../source\n---\n\n# 引言\n\n在C和C++开发中，我们经常会用到printf来进行字符串的格式化，例如`printf(\"format string %d, %d\", 1, 2);`，这样的格式化只是用于打印调试信息。printf函数实现的是接收可变参数，然后解析格式化的字符串，最后输出到控制台。那么问题来了，当我们需要实现一个函数，根据传入的可变参数来生成格式化的字符串，应该怎么办呢？\n\n# 正文\n\n## 可变参数\n\n首先来一个可变参数使用示例，`testVariadic`方法接收int行的可变参数，并以可变参数为-1表示结束。va_list用于遍历可变参数，`va_start`方法接收两个参数，第一个为`va_list`，第二个为可变参数前一个参数，下面的例子里该参数为a。\n\n```c\n/**\n 下面是 <stdarg.h> 里面重要的几个宏定义如下：\n typedef char* va_list;\n void va_start ( va_list ap, prev_param ); // ANSI version\n type va_arg ( va_list ap, type );\n void va_end ( va_list ap );\n va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。\n <Step 1> 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；\n <Step 2> 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数；\n <Step 3> 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；\n <Step 4> 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。\n */\n//-1表示可变参数结束\nvoid receiveVariadic(int a, ...) {\n    va_list list;\n    va_start(list, a);\n    int arg = a;\n    while (arg != -1) {\n        arg = va_arg(list, int);\n        printf(\"%d \", arg);\n    }\n    printf(\"\\n\");\n    va_end(list);\n}\n\n//test\nvoid testVari()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    //-1表示可变参数结束\n    receiveVariadic(1, 2, 3, 4, 5, 6, -1);\n}\n```\n\n运行结果\n\n```\n------testVari------\n2 3 4 5 6 -1 \n```\n\n## 格式化字符串\n\n好了，我们已经介绍了怎样实现一个接收可变参数的C函数，接下来介绍根据接收的可变参数来格式化字符串。这里介绍两种方式，第一种是利用宏定义，第二种通过函数的方式来实现。\n\n### 通过宏定义的方式\n\nen…让咱们先来看看第一个版本的宏，这个宏定义对于不熟悉宏的人来说可能看着有点费劲，不过不要怕，稍后会做解释，代码如下：\n\n```c\n#define myFormatStringByMacro_WithoutReturn(format, ...) \\\ndo { \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    printf(\"%s\", buf); \\\n    free(buf); \\\n} while(0)\n\n```\n\n#### 宏基础知识\n\n首先需要介绍宏用到的知识：`\\`, 这个`\\`的作用是可换行定义宏，毕竟如果一行很长的宏可读性很差，使用方式在换行时加上`\\`即可。第二个是介绍`(format, ...)`，这里的`...`是预定义的宏，用于接收可变参数，就像是`printf`函数一样。接着介绍`##__VA_ARGS__`，同样的`__VA_ARGS__`也是预定义的宏，表示接收到的`...`传入的可变参数。`##`的作用是用来处理未传入可变参数的情况，当没有传入可变参数的时候，编译器或通过优化将`snprintf(NULL, 0, format, ##__VA_ARGS__);`优化为`snprintf(NULL, 0, format);`。你可以理解为没有可变参数时，`##`前的逗号`,`与`__VA_ARGS__`都被“干掉了”。\n\n你一定会觉得困惑，为什么要写`do-while`语句呢？这是为了宏的健壮性，如果使用宏的人像下面这样使用的话，就会出问题\n\n```c\n#define testMarco(a, b) \\\nint _a = a + 1; \\\nint _b = b + 1; \\\nprintf(\"\\n%d\", _a + _b); \\\n\nvoid test()\n{\n    if (1 > 0)\n        testMarco(1, 2);\n}\n```\n\n上面的代码连编译都不会通过, 会报错如下:\n\n![](/images/macro_1.png)\n\n如果手动展开这个宏的话，会变成这个样子，问题就显而易见了。但是如果`if`语句加上了`{}`的话，就不会有问题，可以看出规范写法是多么的重要🐶（皮一下很开心）。\n\n```c\nvoid test()\n{\n    if (1 > 0)\n        int _a = 1 + 1; int _b = 2 + 1; printf(\"\\n%d\", _a + _b);;\n}\n```\n\n加上`do-while`以后就不一样，加上do-while后的代码如下：\n\n```c\n#define testMarco(a, b) \\\ndo { \\\nint _a = a + 1; \\\nint _b = b + 1; \\\nprintf(\"\\n%d\", _a + _b); \\\n} while(0)\n\nvoid test()\n{\n    if (1 > 0)\n        testMarco(1, 2);\n}\n\n\n```\n\n预处理之后代码如下：\n\n```c\n//展开后的代码 \nvoid test()\n{\n    if (1 > 0)\n        do { int _a = 1 + 1; int _b = 2 + 1; printf(\"\\n%d\", _a + _b); } while(0);\n}\n```\n\n好了，宏的基础知识就介绍这么多了，接下来进入正题。\n\n#### 代码解析\n\n为了方便阅读，原谅我在这里再贴一遍宏定义的代码：\n\n```c\n#define myFormatStringByMacro_WithoutReturn(format, ...) \\\ndo { \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    printf(\"%s\", buf); \\\n    free(buf); \\\n} while(0)\n```\n\n首先，介绍一下`snprintf()`函数，此函数的定义如下：\n\n```c\n/**\n \n @param __str 接收格式化结果的指针\n @param __size 接收的size\n @param __format 格式化的字符串\n @param ... 可变参数\n @return 返回格式化后实际上写入的大小a，a <= __size\n */\nint     snprintf(char * __restrict __str, size_t __size, const char * __restrict __format, ...) __printflike(3, 4);\n```\n\n为了方便理解，使用方式是这个样子的：\n\n```c\nvoid testSnprintf()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char des[50];\n    int size = snprintf(des, 50, \"less length %d\", 50);\n    printf(\"size:%d\\n\", size);\n}\n```\n\n运行结果：\n\n```\n------testSnprintf------\nsize:14\n```\n\n`snprintf`函数还有一个用法是`__str`和`__size`分别传入NULL和0，返回值会是格式化字符串的实际长度，可以通过这个方式来获取正确的格式化size，从而避免malloc多余的空间，造成空间浪费。同时返回的size是不包含结束符`\\0`的，所以真正写入要buffer时，需要对size + 1。\n\n相信通过我的解释，你一定能看懂上面这段代码了吧。哦，对了malloc的代码一定要记得free（敲重点）。\n\n到了这里，如果细心思考的同学一定会问？这个宏根本没有实际用途好不好，我要的是能够把格式化的字符串作为返回值返回的，仅仅打印直接用`printf`不就好了。其实，这样的宏还是有作用的，比如说当你要记录日志时，你可以像这样使用：\n\n```c\n#define Log_Debug(format, ...) \\\ndo { \\\nint size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\nsize++; \\\nchar *buf = (char *)malloc(size); \\\nsnprintf(buf, size, format, ##__VA_ARGS__); \\\ndoLog(buf); \\\nfree(buf); \\\n} while(0)\n```\n\n要将结果字符串返回的话，需要用到GNU C的赋值扩展，使用方式如下:\n\n```c\nint a = ({\n        int b = 2;\n        int c = 4;\n        b + c;\n    });\n```\n\n这段代码变量a最终值会是6。利用gnu这个扩展，将之前的宏改造一下就能实现我们的需求，改造完成后是这个样子的：\n\n```c\n#define myFormatStringByMacro_ReturnFormatString(format, ...) \\\n({ \\\n    int size = snprintf(NULL, 0, format, ##__VA_ARGS__);\\\n    size++; \\\n    char *buf = (char *)malloc(size); \\\n    snprintf(buf, size, format, ##__VA_ARGS__); \\\n    buf; \\\n});\n```\n\n调用宏的代码：\n\n```c\nvoid testByMacro1()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *a = myFormatStringByMacro_ReturnFormatString(\"format by macro, %d %s\", 123, \"well done\");\n    printf(\"%s\\n\", a);\n    free(a);\n}\n```\n\n原谅我的啰嗦，malloc开辟的空间一定要记得free。运行结果：\n\n```c\n------testByMacro1------\nformat by macro, 123 well done\n```\n\n至此利用宏的方式就介绍完了。\n\n### 通过函数的方式\n\n老规矩先上代码\n\n```c\nchar *myFormatStringByFun(char *format, ...)\n{\n    va_list list;\n    //1. 先获取格式化后字符串的长度\n    va_start(list, format);\n    int size = vsnprintf(NULL, 0, format, list);\n    va_end(list);\n    if(size <= 0) {\n        return NULL;\n    }\n    size++;\n    \n    //2. 复位va_list，将格式化字符串写入到buf\n    va_start(list, format);\n    char *buf = (char *)malloc(size);\n    vsnprintf(buf, size, format, list);\n    va_end(list);\n    return buf;\n}\n```\n\n这里利用的是`vsnprintf`函数，此函数的定义在`stdio.h`中的定义如下：\n\n```c\n/**\n\n @param __str 目标字符串\n @param __size 要赋值的大小\n @param __format 格式化字符串\n @param va_list 可变参数列表\n @return 返回格式化后实际上写入的大小a，a <= __size\n */\nint     vsnprintf(char * __restrict __str, size_t __size, const char * __restrict __format, va_list) __printflike(3, 0);\n```\n\n`vsnprintf`的具体使用方式和之前介绍的`snprintf`是差不多的，这里就不再详细介绍了，不大明白的同学可以看看上面的介绍。哦，对了，这两个函数都是定义在stdio.h这个头文件下的\n\n接下来就是试一下我们封装的函数了\n\n```c\nvoid testByFun()\n{\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *b = myFormatStringByFun(\"format by fun %d %s\", 321, \"nice\");\n    printf(\"%s\\n\", b);\n}\n```\n\n运行结果：\n\n```c\n------testByFun------\nformat by fun 321 nice\n```\n\n格式化字符串的方法差不多介绍完了，不知道善于思考的你有没想到直接用宏定义来调用我们封装的函数呢？我就在这直接给出宏定义和使用方式了\n\n```c\n#define myFormatStringByFunQuick(format, ...) myFormatStringByFun(format, ##__VA_ARGS__);\nvoid testMyFormatStringByFunQuick() {\n    printf(\"------%s------\\n\", __FUNCTION__);\n    char *formatString = myFormatStringByFunQuick(\"amazing happen, %s\", \"cool\");\n    printf(\"%s\\n\", formatString);\n}\n```\n\n运行结果：\n\n```c\n------testMyFormatStringByFunQuick------\namazing happen\n```\n\n### C++版本\n\n对了，最初实现是用的C++版本，这里使用的是泛型，代码是这个样子的：\n\n```c++\ntemplate< typename... Args >\nstd::string string_sprintf( const char* format, Args... args ) {\n    int length = std::snprintf( nullptr, 0, format, args... );\n    assert( length >= 0 );\n    \n    char* buf = new char[length + 1];\n    std::snprintf( buf, length + 1, format, args... );\n    \n    std::string str( buf );\n    delete[] buf;\n    return str;\n}\n```\n\n其实和C语言版本的没什么差别，只是多了泛型的东西而已，相信聪明的你一定能看懂，看不懂的话，就去看看C++的泛型知识吧，哈哈哈。\n\n# 结语\n\n终于介绍完了，你可以在[这里](https://github.com/WuKongCoo1/DemoFormatString)下载代码。写博客是真的有点累人，不过对于最近被面试打击的我来说，写博客能够让我对知识理解的更加透彻，毕竟要自己认真思考后才能够写的明白（至少我觉得讲明白了，哈哈哈）。如果有什么说的不对的地方，还请指出，感谢你的阅读，thks。\n\n# 参考资料\n\n[std::string formatting like sprintf](https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf)\n\n[宏定义的黑魔法 - 宏菜鸟起飞手册](https://onevcat.com/2014/01/black-magic-in-macro/)\n\n[整理：C/C++可变参数，“## __VA_ARGS__”宏的介绍和使用](https://blog.csdn.net/bat67/article/details/77542165)","slug":"C、CPlusPlus格式化字符串","published":1,"updated":"2019-09-10T06:02:13.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyukm0004oqs6vun1ofpz","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在C和C++开发中，我们经常会用到printf来进行字符串的格式化，例如<code>printf(&quot;format string %d, %d&quot;, 1, 2);</code>，这样的格式化只是用于打印调试信息。printf函数实现的是接收可变参数，然后解析格式化的字符串，最后输出到控制台。那么问题来了，当我们需要实现一个函数，根据传入的可变参数来生成格式化的字符串，应该怎么办呢？</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>首先来一个可变参数使用示例，<code>testVariadic</code>方法接收int行的可变参数，并以可变参数为-1表示结束。va_list用于遍历可变参数，<code>va_start</code>方法接收两个参数，第一个为<code>va_list</code>，第二个为可变参数前一个参数，下面的例子里该参数为a。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：</span></span><br><span class=\"line\"><span class=\"comment\"> typedef char* va_list;</span></span><br><span class=\"line\"><span class=\"comment\"> void va_start ( va_list ap, prev_param ); // ANSI version</span></span><br><span class=\"line\"><span class=\"comment\"> type va_arg ( va_list ap, type );</span></span><br><span class=\"line\"><span class=\"comment\"> void va_end ( va_list ap );</span></span><br><span class=\"line\"><span class=\"comment\"> va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 1&gt; 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 2&gt; 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 3&gt; 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 4&gt; 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//-1表示可变参数结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">receiveVariadic</span><span class=\"params\">(<span class=\"keyword\">int</span> a, ...)</span> </span>&#123;</span><br><span class=\"line\">    va_list <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, a);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arg = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arg != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        arg = va_arg(<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testVari</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"comment\">//-1表示可变参数结束</span></span><br><span class=\"line\">    receiveVariadic(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testVari------</span><br><span class=\"line\">2 3 4 5 6 -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h2><p>好了，我们已经介绍了怎样实现一个接收可变参数的C函数，接下来介绍根据接收的可变参数来格式化字符串。这里介绍两种方式，第一种是利用宏定义，第二种通过函数的方式来实现。</p>\n<h3 id=\"通过宏定义的方式\"><a href=\"#通过宏定义的方式\" class=\"headerlink\" title=\"通过宏定义的方式\"></a>通过宏定义的方式</h3><p>en…让咱们先来看看第一个版本的宏，这个宏定义对于不熟悉宏的人来说可能看着有点费劲，不过不要怕，稍后会做解释，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_WithoutReturn(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, buf); \\</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"宏基础知识\"><a href=\"#宏基础知识\" class=\"headerlink\" title=\"宏基础知识\"></a>宏基础知识</h4><p>首先需要介绍宏用到的知识：<code>\\</code>, 这个<code>\\</code>的作用是可换行定义宏，毕竟如果一行很长的宏可读性很差，使用方式在换行时加上<code>\\</code>即可。第二个是介绍<code>(format, ...)</code>，这里的<code>...</code>是预定义的宏，用于接收可变参数，就像是<code>printf</code>函数一样。接着介绍<code>##__VA_ARGS__</code>，同样的<code>__VA_ARGS__</code>也是预定义的宏，表示接收到的<code>...</code>传入的可变参数。<code>##</code>的作用是用来处理未传入可变参数的情况，当没有传入可变参数的时候，编译器或通过优化将<code>snprintf(NULL, 0, format, ##__VA_ARGS__);</code>优化为<code>snprintf(NULL, 0, format);</code>。你可以理解为没有可变参数时，<code>##</code>前的逗号<code>,</code>与<code>__VA_ARGS__</code>都被“干掉了”。</p>\n<p>你一定会觉得困惑，为什么要写<code>do-while</code>语句呢？这是为了宏的健壮性，如果使用宏的人像下面这样使用的话，就会出问题</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> testMarco(a, b) \\</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _a = a + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _b = b + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        testMarco(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码连编译都不会通过, 会报错如下:</p>\n<p><img src=\"/images/macro_1.png\" alt></p>\n<p>如果手动展开这个宏的话，会变成这个样子，问题就显而易见了。但是如果<code>if</code>语句加上了<code>{}</code>的话，就不会有问题，可以看出规范写法是多么的重要🐶（皮一下很开心）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">int</span> _a = <span class=\"number\">1</span> + <span class=\"number\">1</span>; <span class=\"keyword\">int</span> _b = <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b);;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上<code>do-while</code>以后就不一样，加上do-while后的代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> testMarco(a, b) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _a = a + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _b = b + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        testMarco(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//展开后的代码 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">int</span> _a = <span class=\"number\">1</span> + <span class=\"number\">1</span>; <span class=\"keyword\">int</span> _b = <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); &#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，宏的基础知识就介绍这么多了，接下来进入正题。</p>\n<h4 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h4><p>为了方便阅读，原谅我在这里再贴一遍宏定义的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_WithoutReturn(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, buf); \\</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>首先，介绍一下<code>snprintf()</code>函数，此函数的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> @param __str 接收格式化结果的指针</span></span><br><span class=\"line\"><span class=\"comment\"> @param __size 接收的size</span></span><br><span class=\"line\"><span class=\"comment\"> @param __format 格式化的字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param ... 可变参数</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回格式化后实际上写入的大小a，a &lt;= __size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>     <span class=\"title\">snprintf</span><span class=\"params\">(<span class=\"keyword\">char</span> * __restrict __str, <span class=\"keyword\">size_t</span> __size, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * __restrict __format, ...)</span> __<span class=\"title\">printflike</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便理解，使用方式是这个样子的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testSnprintf</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> des[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(des, <span class=\"number\">50</span>, <span class=\"string\">\"less length %d\"</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"size:%d\\n\"</span>, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testSnprintf------</span><br><span class=\"line\">size:14</span><br></pre></td></tr></table></figure>\n\n<p><code>snprintf</code>函数还有一个用法是<code>__str</code>和<code>__size</code>分别传入NULL和0，返回值会是格式化字符串的实际长度，可以通过这个方式来获取正确的格式化size，从而避免malloc多余的空间，造成空间浪费。同时返回的size是不包含结束符<code>\\0</code>的，所以真正写入要buffer时，需要对size + 1。</p>\n<p>相信通过我的解释，你一定能看懂上面这段代码了吧。哦，对了malloc的代码一定要记得free（敲重点）。</p>\n<p>到了这里，如果细心思考的同学一定会问？这个宏根本没有实际用途好不好，我要的是能够把格式化的字符串作为返回值返回的，仅仅打印直接用<code>printf</code>不就好了。其实，这样的宏还是有作用的，比如说当你要记录日志时，你可以像这样使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Log_Debug(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">size++; \\</span><br><span class=\"line\"><span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\"><span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">doLog(buf); \\</span><br><span class=\"line\"><span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>要将结果字符串返回的话，需要用到GNU C的赋值扩展，使用方式如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = (&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">4</span>;</span><br><span class=\"line\">        b + c;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码变量a最终值会是6。利用gnu这个扩展，将之前的宏改造一下就能实现我们的需求，改造完成后是这个样子的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_ReturnFormatString(format, ...) \\</span></span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    buf; \\</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>调用宏的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testByMacro1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *a = myFormatStringByMacro_ReturnFormatString(<span class=\"string\">\"format by macro, %d %s\"</span>, <span class=\"number\">123</span>, <span class=\"string\">\"well done\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原谅我的啰嗦，malloc开辟的空间一定要记得free。运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testByMacro1------</span><br><span class=\"line\">format by macro, <span class=\"number\">123</span> well done</span><br></pre></td></tr></table></figure>\n\n<p>至此利用宏的方式就介绍完了。</p>\n<h3 id=\"通过函数的方式\"><a href=\"#通过函数的方式\" class=\"headerlink\" title=\"通过函数的方式\"></a>通过函数的方式</h3><p>老规矩先上代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">myFormatStringByFun</span><span class=\"params\">(<span class=\"keyword\">char</span> *format, ...)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    va_list <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"comment\">//1. 先获取格式化后字符串的长度</span></span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, format);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = vsnprintf(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2. 复位va_list，将格式化字符串写入到buf</span></span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, format);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">    vsnprintf(buf, size, format, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里利用的是<code>vsnprintf</code>函数，此函数的定义在<code>stdio.h</code>中的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param __str 目标字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param __size 要赋值的大小</span></span><br><span class=\"line\"><span class=\"comment\"> @param __format 格式化字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param va_list 可变参数列表</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回格式化后实际上写入的大小a，a &lt;= __size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>     <span class=\"title\">vsnprintf</span><span class=\"params\">(<span class=\"keyword\">char</span> * __restrict __str, <span class=\"keyword\">size_t</span> __size, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * __restrict __format, va_list)</span> __<span class=\"title\">printflike</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>vsnprintf</code>的具体使用方式和之前介绍的<code>snprintf</code>是差不多的，这里就不再详细介绍了，不大明白的同学可以看看上面的介绍。哦，对了，这两个函数都是定义在stdio.h这个头文件下的</p>\n<p>接下来就是试一下我们封装的函数了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testByFun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *b = myFormatStringByFun(<span class=\"string\">\"format by fun %d %s\"</span>, <span class=\"number\">321</span>, <span class=\"string\">\"nice\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testByFun------</span><br><span class=\"line\">format by fun <span class=\"number\">321</span> nice</span><br></pre></td></tr></table></figure>\n\n<p>格式化字符串的方法差不多介绍完了，不知道善于思考的你有没想到直接用宏定义来调用我们封装的函数呢？我就在这直接给出宏定义和使用方式了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByFunQuick(format, ...) myFormatStringByFun(format, ##__VA_ARGS__);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testMyFormatStringByFunQuick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *formatString = myFormatStringByFunQuick(<span class=\"string\">\"amazing happen, %s\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, formatString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testMyFormatStringByFunQuick------</span><br><span class=\"line\">amazing happen</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++版本\"></a>C++版本</h3><p>对了，最初实现是用的C++版本，这里使用的是泛型，代码是这个样子的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"keyword\">typename</span>... Args &gt;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">string_sprintf</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* format, Args... args )</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"built_in\">std</span>::<span class=\"built_in\">snprintf</span>( <span class=\"literal\">nullptr</span>, <span class=\"number\">0</span>, format, args... );</span><br><span class=\"line\">    assert( length &gt;= <span class=\"number\">0</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>* buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[length + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">snprintf</span>( buf, length + <span class=\"number\">1</span>, format, args... );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">str</span><span class=\"params\">( buf )</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] buf;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实和C语言版本的没什么差别，只是多了泛型的东西而已，相信聪明的你一定能看懂，看不懂的话，就去看看C++的泛型知识吧，哈哈哈。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>终于介绍完了，你可以在<a href=\"https://github.com/WuKongCoo1/DemoFormatString\" target=\"_blank\" rel=\"noopener\">这里</a>下载代码。写博客是真的有点累人，不过对于最近被面试打击的我来说，写博客能够让我对知识理解的更加透彻，毕竟要自己认真思考后才能够写的明白（至少我觉得讲明白了，哈哈哈）。如果有什么说的不对的地方，还请指出，感谢你的阅读，thks。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf\" target=\"_blank\" rel=\"noopener\">std::string formatting like sprintf</a></p>\n<p><a href=\"https://onevcat.com/2014/01/black-magic-in-macro/\" target=\"_blank\" rel=\"noopener\">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>\n<p><a href=\"https://blog.csdn.net/bat67/article/details/77542165\" target=\"_blank\" rel=\"noopener\">整理：C/C++可变参数，“## <strong>VA_ARGS</strong>”宏的介绍和使用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在C和C++开发中，我们经常会用到printf来进行字符串的格式化，例如<code>printf(&quot;format string %d, %d&quot;, 1, 2);</code>，这样的格式化只是用于打印调试信息。printf函数实现的是接收可变参数，然后解析格式化的字符串，最后输出到控制台。那么问题来了，当我们需要实现一个函数，根据传入的可变参数来生成格式化的字符串，应该怎么办呢？</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>首先来一个可变参数使用示例，<code>testVariadic</code>方法接收int行的可变参数，并以可变参数为-1表示结束。va_list用于遍历可变参数，<code>va_start</code>方法接收两个参数，第一个为<code>va_list</code>，第二个为可变参数前一个参数，下面的例子里该参数为a。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 下面是 &lt;stdarg.h&gt; 里面重要的几个宏定义如下：</span></span><br><span class=\"line\"><span class=\"comment\"> typedef char* va_list;</span></span><br><span class=\"line\"><span class=\"comment\"> void va_start ( va_list ap, prev_param ); // ANSI version</span></span><br><span class=\"line\"><span class=\"comment\"> type va_arg ( va_list ap, type );</span></span><br><span class=\"line\"><span class=\"comment\"> void va_end ( va_list ap );</span></span><br><span class=\"line\"><span class=\"comment\"> va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 1&gt; 在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 2&gt; 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 3&gt; 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；</span></span><br><span class=\"line\"><span class=\"comment\"> &lt;Step 4&gt; 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL，应该养成获取完参数表之后关闭指针的习惯。说白了，就是让我们的程序具有健壮性。通常va_start和va_end是成对出现。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//-1表示可变参数结束</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">receiveVariadic</span><span class=\"params\">(<span class=\"keyword\">int</span> a, ...)</span> </span>&#123;</span><br><span class=\"line\">    va_list <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, a);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arg = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arg != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        arg = va_arg(<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testVari</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"comment\">//-1表示可变参数结束</span></span><br><span class=\"line\">    receiveVariadic(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testVari------</span><br><span class=\"line\">2 3 4 5 6 -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h2><p>好了，我们已经介绍了怎样实现一个接收可变参数的C函数，接下来介绍根据接收的可变参数来格式化字符串。这里介绍两种方式，第一种是利用宏定义，第二种通过函数的方式来实现。</p>\n<h3 id=\"通过宏定义的方式\"><a href=\"#通过宏定义的方式\" class=\"headerlink\" title=\"通过宏定义的方式\"></a>通过宏定义的方式</h3><p>en…让咱们先来看看第一个版本的宏，这个宏定义对于不熟悉宏的人来说可能看着有点费劲，不过不要怕，稍后会做解释，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_WithoutReturn(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, buf); \\</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"宏基础知识\"><a href=\"#宏基础知识\" class=\"headerlink\" title=\"宏基础知识\"></a>宏基础知识</h4><p>首先需要介绍宏用到的知识：<code>\\</code>, 这个<code>\\</code>的作用是可换行定义宏，毕竟如果一行很长的宏可读性很差，使用方式在换行时加上<code>\\</code>即可。第二个是介绍<code>(format, ...)</code>，这里的<code>...</code>是预定义的宏，用于接收可变参数，就像是<code>printf</code>函数一样。接着介绍<code>##__VA_ARGS__</code>，同样的<code>__VA_ARGS__</code>也是预定义的宏，表示接收到的<code>...</code>传入的可变参数。<code>##</code>的作用是用来处理未传入可变参数的情况，当没有传入可变参数的时候，编译器或通过优化将<code>snprintf(NULL, 0, format, ##__VA_ARGS__);</code>优化为<code>snprintf(NULL, 0, format);</code>。你可以理解为没有可变参数时，<code>##</code>前的逗号<code>,</code>与<code>__VA_ARGS__</code>都被“干掉了”。</p>\n<p>你一定会觉得困惑，为什么要写<code>do-while</code>语句呢？这是为了宏的健壮性，如果使用宏的人像下面这样使用的话，就会出问题</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> testMarco(a, b) \\</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> _a = a + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _b = b + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        testMarco(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码连编译都不会通过, 会报错如下:</p>\n<p><img src=\"/images/macro_1.png\" alt></p>\n<p>如果手动展开这个宏的话，会变成这个样子，问题就显而易见了。但是如果<code>if</code>语句加上了<code>{}</code>的话，就不会有问题，可以看出规范写法是多么的重要🐶（皮一下很开心）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">int</span> _a = <span class=\"number\">1</span> + <span class=\"number\">1</span>; <span class=\"keyword\">int</span> _b = <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b);;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上<code>do-while</code>以后就不一样，加上do-while后的代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> testMarco(a, b) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _a = a + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> _b = b + <span class=\"number\">1</span>; \\</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        testMarco(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//展开后的代码 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">int</span> _a = <span class=\"number\">1</span> + <span class=\"number\">1</span>; <span class=\"keyword\">int</span> _b = <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, _a + _b); &#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，宏的基础知识就介绍这么多了，接下来进入正题。</p>\n<h4 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h4><p>为了方便阅读，原谅我在这里再贴一遍宏定义的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_WithoutReturn(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, buf); \\</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>首先，介绍一下<code>snprintf()</code>函数，此函数的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> @param __str 接收格式化结果的指针</span></span><br><span class=\"line\"><span class=\"comment\"> @param __size 接收的size</span></span><br><span class=\"line\"><span class=\"comment\"> @param __format 格式化的字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param ... 可变参数</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回格式化后实际上写入的大小a，a &lt;= __size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>     <span class=\"title\">snprintf</span><span class=\"params\">(<span class=\"keyword\">char</span> * __restrict __str, <span class=\"keyword\">size_t</span> __size, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * __restrict __format, ...)</span> __<span class=\"title\">printflike</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便理解，使用方式是这个样子的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testSnprintf</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> des[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(des, <span class=\"number\">50</span>, <span class=\"string\">\"less length %d\"</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"size:%d\\n\"</span>, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testSnprintf------</span><br><span class=\"line\">size:14</span><br></pre></td></tr></table></figure>\n\n<p><code>snprintf</code>函数还有一个用法是<code>__str</code>和<code>__size</code>分别传入NULL和0，返回值会是格式化字符串的实际长度，可以通过这个方式来获取正确的格式化size，从而避免malloc多余的空间，造成空间浪费。同时返回的size是不包含结束符<code>\\0</code>的，所以真正写入要buffer时，需要对size + 1。</p>\n<p>相信通过我的解释，你一定能看懂上面这段代码了吧。哦，对了malloc的代码一定要记得free（敲重点）。</p>\n<p>到了这里，如果细心思考的同学一定会问？这个宏根本没有实际用途好不好，我要的是能够把格式化的字符串作为返回值返回的，仅仅打印直接用<code>printf</code>不就好了。其实，这样的宏还是有作用的，比如说当你要记录日志时，你可以像这样使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Log_Debug(format, ...) \\</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\"><span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">size++; \\</span><br><span class=\"line\"><span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\"><span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">doLog(buf); \\</span><br><span class=\"line\"><span class=\"built_in\">free</span>(buf); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>要将结果字符串返回的话，需要用到GNU C的赋值扩展，使用方式如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = (&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">4</span>;</span><br><span class=\"line\">        b + c;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码变量a最终值会是6。利用gnu这个扩展，将之前的宏改造一下就能实现我们的需求，改造完成后是这个样子的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByMacro_ReturnFormatString(format, ...) \\</span></span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"built_in\">snprintf</span>(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, ##__VA_ARGS__);\\</span><br><span class=\"line\">    size++; \\</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size); \\</span><br><span class=\"line\">    <span class=\"built_in\">snprintf</span>(buf, size, format, ##__VA_ARGS__); \\</span><br><span class=\"line\">    buf; \\</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>调用宏的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testByMacro1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *a = myFormatStringByMacro_ReturnFormatString(<span class=\"string\">\"format by macro, %d %s\"</span>, <span class=\"number\">123</span>, <span class=\"string\">\"well done\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原谅我的啰嗦，malloc开辟的空间一定要记得free。运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testByMacro1------</span><br><span class=\"line\">format by macro, <span class=\"number\">123</span> well done</span><br></pre></td></tr></table></figure>\n\n<p>至此利用宏的方式就介绍完了。</p>\n<h3 id=\"通过函数的方式\"><a href=\"#通过函数的方式\" class=\"headerlink\" title=\"通过函数的方式\"></a>通过函数的方式</h3><p>老规矩先上代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">myFormatStringByFun</span><span class=\"params\">(<span class=\"keyword\">char</span> *format, ...)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    va_list <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    <span class=\"comment\">//1. 先获取格式化后字符串的长度</span></span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, format);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = vsnprintf(<span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, format, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2. 复位va_list，将格式化字符串写入到buf</span></span><br><span class=\"line\">    va_start(<span class=\"built_in\">list</span>, format);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">    vsnprintf(buf, size, format, <span class=\"built_in\">list</span>);</span><br><span class=\"line\">    va_end(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里利用的是<code>vsnprintf</code>函数，此函数的定义在<code>stdio.h</code>中的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"> @param __str 目标字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param __size 要赋值的大小</span></span><br><span class=\"line\"><span class=\"comment\"> @param __format 格式化字符串</span></span><br><span class=\"line\"><span class=\"comment\"> @param va_list 可变参数列表</span></span><br><span class=\"line\"><span class=\"comment\"> @return 返回格式化后实际上写入的大小a，a &lt;= __size</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>     <span class=\"title\">vsnprintf</span><span class=\"params\">(<span class=\"keyword\">char</span> * __restrict __str, <span class=\"keyword\">size_t</span> __size, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * __restrict __format, va_list)</span> __<span class=\"title\">printflike</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>vsnprintf</code>的具体使用方式和之前介绍的<code>snprintf</code>是差不多的，这里就不再详细介绍了，不大明白的同学可以看看上面的介绍。哦，对了，这两个函数都是定义在stdio.h这个头文件下的</p>\n<p>接下来就是试一下我们封装的函数了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testByFun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *b = myFormatStringByFun(<span class=\"string\">\"format by fun %d %s\"</span>, <span class=\"number\">321</span>, <span class=\"string\">\"nice\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testByFun------</span><br><span class=\"line\">format by fun <span class=\"number\">321</span> nice</span><br></pre></td></tr></table></figure>\n\n<p>格式化字符串的方法差不多介绍完了，不知道善于思考的你有没想到直接用宏定义来调用我们封装的函数呢？我就在这直接给出宏定义和使用方式了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> myFormatStringByFunQuick(format, ...) myFormatStringByFun(format, ##__VA_ARGS__);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testMyFormatStringByFunQuick</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"------%s------\\n\"</span>, __FUNCTION__);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *formatString = myFormatStringByFunQuick(<span class=\"string\">\"amazing happen, %s\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, formatString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------testMyFormatStringByFunQuick------</span><br><span class=\"line\">amazing happen</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-版本\"><a href=\"#C-版本\" class=\"headerlink\" title=\"C++版本\"></a>C++版本</h3><p>对了，最初实现是用的C++版本，这里使用的是泛型，代码是这个样子的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt; <span class=\"keyword\">typename</span>... Args &gt;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">string_sprintf</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* format, Args... args )</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"built_in\">std</span>::<span class=\"built_in\">snprintf</span>( <span class=\"literal\">nullptr</span>, <span class=\"number\">0</span>, format, args... );</span><br><span class=\"line\">    assert( length &gt;= <span class=\"number\">0</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>* buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[length + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">snprintf</span>( buf, length + <span class=\"number\">1</span>, format, args... );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">str</span><span class=\"params\">( buf )</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] buf;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实和C语言版本的没什么差别，只是多了泛型的东西而已，相信聪明的你一定能看懂，看不懂的话，就去看看C++的泛型知识吧，哈哈哈。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>终于介绍完了，你可以在<a href=\"https://github.com/WuKongCoo1/DemoFormatString\" target=\"_blank\" rel=\"noopener\">这里</a>下载代码。写博客是真的有点累人，不过对于最近被面试打击的我来说，写博客能够让我对知识理解的更加透彻，毕竟要自己认真思考后才能够写的明白（至少我觉得讲明白了，哈哈哈）。如果有什么说的不对的地方，还请指出，感谢你的阅读，thks。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf\" target=\"_blank\" rel=\"noopener\">std::string formatting like sprintf</a></p>\n<p><a href=\"https://onevcat.com/2014/01/black-magic-in-macro/\" target=\"_blank\" rel=\"noopener\">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>\n<p><a href=\"https://blog.csdn.net/bat67/article/details/77542165\" target=\"_blank\" rel=\"noopener\">整理：C/C++可变参数，“## <strong>VA_ARGS</strong>”宏的介绍和使用</a></p>\n"},{"title":"Mac OpenGL环境搭建","date":"2019-08-20T13:10:26.000Z","_content":"\n# MAC OpenGL 环境搭建\n\n## 基础库介绍\n\n先要安装两个库一个是GLEW（OpenGL Extension Wrangler Library），另外一个是GLFW（Graphics Library Framework）\n\n### GLEW \n\n譯自英文-OpenGL擴展Wrangler庫是一個跨平台的C / C ++庫，可幫助查詢和加載OpenGL擴展。 GLEW提供了高效的運行時機制，用於確定目標平台上支持哪些OpenGL擴展。所有OpenGL擴展都在一個頭文件中公開，該文件是從官方擴展名列表機器生成的\n\n### GLFW\n\nGLFW 是配合 OpenGL 使用的轻量级工具程序库，缩写自 Graphics Library Framework（图形库框架）。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。\n\n## 进入安装步骤\n\n### 准备工作\n\n要进行安装的话需要先安装CMake，可以选择使用GUI 方式 或者命令行的方式。GUI可以在这里[下载](https://cmake.org/download/)，命令行的方式的话，可以用brew来安装，方式如下\n\n```shell\nbrew install cmake\n```\n\n### 安装GLEW\n\n首先在这里下载[源码](http://glew.sourceforge.net/)，下载以后，解压文件，然后进入到文件所在路径，打开终端进入到此路径，执行命令\n\n```shell\nsudo make install\n```\n\n### 安装GLFW\n\n首先在[这里](https://www.glfw.org/download.html)下载源码，我们可以选择直接下载编译好的库，也可以下载源文件然后通过camke来自己编译，区别是如果用cmake库的话，在执行成功以后，会直接将生成的库与头文件分别添加到系统路径，也就是/usr/local/include和/usr/local/lib。这里就自己选择方式了。我在这里介绍利用make工具，自己编译的方式\n\n打开cmake 的gui工具，在source code选择下载的glfw路径，这一步需要在这个路径创建一个build目录，用于存放生成的文件。然后在browse build路径选择我们刚才创建的路径，点击configure。\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143441915-1128090430.png)\n\n生成成功会出现如下效果\n\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143348522-1218740224.png)\n\n\n接下来从终端进入到build目录，没错就是刚才我们创建的build，输入如下指令\n\n```shell\nsudo make\nsudo make install\n```\n\n执行成功后，剩成的.a文件与头文件就都放到/usr/local/include和/usr/local/lib了。\n\n环境安装好以后，应该是这个样子的\n\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143328995-1467734221.png)\n\n\n\n至此，环境安装完毕，接下来就是加入到工程了\n\n## 加入工程\n\n### 配置搜索路径\n\n首先我们创建一个command line的工程，然后在build setting里这只user search path，在user search path中设置为：/usr/local/include，这里一定要注意不能选择递归查找，否则会出错。然后设置library search path为：/usr/local/lib。设置这个的作用是工程中明确工程中查找头文件和.a文件的路径。\n\n### 添加要链接的framework\n\n添加以下库文件：\n\n- Cocoa.framework\n- OpenGL.framwork\n- GLUT.framework\n- CoreVideo.framework\n- IOKit.framework\n- libglfw3.a\n- libGLEW.a\n\n![库文件](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143224335-1252417188.png)\n\n其中，libglfw3.a、libGLEW.a需要点击 add another，然后进入要路径/usr/local/lib中添加。\n\n配置完成以后，就可以写代码了，进入main.cpp文件，将main中修改如下\n\n```c++\n#include <iostream>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\nvoid Render(void)\n{\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glBegin(GL_TRIANGLES);\n    {\n        glColor3f(1.0,0.0,0.0);\n        glVertex2f(0, .5);\n        glColor3f(0.0,1.0,0.0);\n        glVertex2f(-.5,-.5);\n        glColor3f(0.0, 0.0, 1.0);\n        glVertex2f(.5, -.5);\n    }\n    glEnd();\n}\nint main(void) {\n    GLFWwindow* win;\n    if(!glfwInit()){\n        return -1;\n    }\n    win = glfwCreateWindow(640, 480, \"OpenGL Base Project\", NULL, NULL);\n    if(!win)\n    {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n    if(!glewInit())\n    {\n        return -1;\n    }\n    glfwMakeContextCurrent(win);\n    while(!glfwWindowShouldClose(win)){\n        Render();\n        glfwSwapBuffers(win);\n        glfwPollEvents();\n    }\n    glfwTerminate();\n    exit(EXIT_SUCCESS);\n    return 0;\n}\n```\n\n见证奇迹的时刻到了，运行，你将会看到一个漂亮的三角形![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143156518-737968913.png)\n\nmac 工程搭建，就说这么多了。\n\n------\n\n感谢以下文章的作者：\n\n[Mac系统下配置OpenGL环境（小白自学版）](https://zhuanlan.zhihu.com/p/24529016)\n\n[OpenGL学习笔记（二）—— (macOS)环境搭建](http://blog.shenyuanluo.com/OpenGLEnvironment.html)","source":"_posts/Mac-OpenGL环境搭建.md","raw":"---\ntitle: Mac OpenGL环境搭建\ndate: 2019-08-20 13:10:26\ntags:\ncategories:\n- [OpenGL]\n---\n\n# MAC OpenGL 环境搭建\n\n## 基础库介绍\n\n先要安装两个库一个是GLEW（OpenGL Extension Wrangler Library），另外一个是GLFW（Graphics Library Framework）\n\n### GLEW \n\n譯自英文-OpenGL擴展Wrangler庫是一個跨平台的C / C ++庫，可幫助查詢和加載OpenGL擴展。 GLEW提供了高效的運行時機制，用於確定目標平台上支持哪些OpenGL擴展。所有OpenGL擴展都在一個頭文件中公開，該文件是從官方擴展名列表機器生成的\n\n### GLFW\n\nGLFW 是配合 OpenGL 使用的轻量级工具程序库，缩写自 Graphics Library Framework（图形库框架）。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。\n\n## 进入安装步骤\n\n### 准备工作\n\n要进行安装的话需要先安装CMake，可以选择使用GUI 方式 或者命令行的方式。GUI可以在这里[下载](https://cmake.org/download/)，命令行的方式的话，可以用brew来安装，方式如下\n\n```shell\nbrew install cmake\n```\n\n### 安装GLEW\n\n首先在这里下载[源码](http://glew.sourceforge.net/)，下载以后，解压文件，然后进入到文件所在路径，打开终端进入到此路径，执行命令\n\n```shell\nsudo make install\n```\n\n### 安装GLFW\n\n首先在[这里](https://www.glfw.org/download.html)下载源码，我们可以选择直接下载编译好的库，也可以下载源文件然后通过camke来自己编译，区别是如果用cmake库的话，在执行成功以后，会直接将生成的库与头文件分别添加到系统路径，也就是/usr/local/include和/usr/local/lib。这里就自己选择方式了。我在这里介绍利用make工具，自己编译的方式\n\n打开cmake 的gui工具，在source code选择下载的glfw路径，这一步需要在这个路径创建一个build目录，用于存放生成的文件。然后在browse build路径选择我们刚才创建的路径，点击configure。\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143441915-1128090430.png)\n\n生成成功会出现如下效果\n\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143348522-1218740224.png)\n\n\n接下来从终端进入到build目录，没错就是刚才我们创建的build，输入如下指令\n\n```shell\nsudo make\nsudo make install\n```\n\n执行成功后，剩成的.a文件与头文件就都放到/usr/local/include和/usr/local/lib了。\n\n环境安装好以后，应该是这个样子的\n\n![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143328995-1467734221.png)\n\n\n\n至此，环境安装完毕，接下来就是加入到工程了\n\n## 加入工程\n\n### 配置搜索路径\n\n首先我们创建一个command line的工程，然后在build setting里这只user search path，在user search path中设置为：/usr/local/include，这里一定要注意不能选择递归查找，否则会出错。然后设置library search path为：/usr/local/lib。设置这个的作用是工程中明确工程中查找头文件和.a文件的路径。\n\n### 添加要链接的framework\n\n添加以下库文件：\n\n- Cocoa.framework\n- OpenGL.framwork\n- GLUT.framework\n- CoreVideo.framework\n- IOKit.framework\n- libglfw3.a\n- libGLEW.a\n\n![库文件](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143224335-1252417188.png)\n\n其中，libglfw3.a、libGLEW.a需要点击 add another，然后进入要路径/usr/local/lib中添加。\n\n配置完成以后，就可以写代码了，进入main.cpp文件，将main中修改如下\n\n```c++\n#include <iostream>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\nvoid Render(void)\n{\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glBegin(GL_TRIANGLES);\n    {\n        glColor3f(1.0,0.0,0.0);\n        glVertex2f(0, .5);\n        glColor3f(0.0,1.0,0.0);\n        glVertex2f(-.5,-.5);\n        glColor3f(0.0, 0.0, 1.0);\n        glVertex2f(.5, -.5);\n    }\n    glEnd();\n}\nint main(void) {\n    GLFWwindow* win;\n    if(!glfwInit()){\n        return -1;\n    }\n    win = glfwCreateWindow(640, 480, \"OpenGL Base Project\", NULL, NULL);\n    if(!win)\n    {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n    if(!glewInit())\n    {\n        return -1;\n    }\n    glfwMakeContextCurrent(win);\n    while(!glfwWindowShouldClose(win)){\n        Render();\n        glfwSwapBuffers(win);\n        glfwPollEvents();\n    }\n    glfwTerminate();\n    exit(EXIT_SUCCESS);\n    return 0;\n}\n```\n\n见证奇迹的时刻到了，运行，你将会看到一个漂亮的三角形![](https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143156518-737968913.png)\n\nmac 工程搭建，就说这么多了。\n\n------\n\n感谢以下文章的作者：\n\n[Mac系统下配置OpenGL环境（小白自学版）](https://zhuanlan.zhihu.com/p/24529016)\n\n[OpenGL学习笔记（二）—— (macOS)环境搭建](http://blog.shenyuanluo.com/OpenGLEnvironment.html)","slug":"Mac-OpenGL环境搭建","published":1,"updated":"2019-08-20T05:13:15.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyukp0006oqs6tiyzvhoy","content":"<h1 id=\"MAC-OpenGL-环境搭建\"><a href=\"#MAC-OpenGL-环境搭建\" class=\"headerlink\" title=\"MAC OpenGL 环境搭建\"></a>MAC OpenGL 环境搭建</h1><h2 id=\"基础库介绍\"><a href=\"#基础库介绍\" class=\"headerlink\" title=\"基础库介绍\"></a>基础库介绍</h2><p>先要安装两个库一个是GLEW（OpenGL Extension Wrangler Library），另外一个是GLFW（Graphics Library Framework）</p>\n<h3 id=\"GLEW\"><a href=\"#GLEW\" class=\"headerlink\" title=\"GLEW\"></a>GLEW</h3><p>譯自英文-OpenGL擴展Wrangler庫是一個跨平台的C / C ++庫，可幫助查詢和加載OpenGL擴展。 GLEW提供了高效的運行時機制，用於確定目標平台上支持哪些OpenGL擴展。所有OpenGL擴展都在一個頭文件中公開，該文件是從官方擴展名列表機器生成的</p>\n<h3 id=\"GLFW\"><a href=\"#GLFW\" class=\"headerlink\" title=\"GLFW\"></a>GLFW</h3><p>GLFW 是配合 OpenGL 使用的轻量级工具程序库，缩写自 Graphics Library Framework（图形库框架）。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。</p>\n<h2 id=\"进入安装步骤\"><a href=\"#进入安装步骤\" class=\"headerlink\" title=\"进入安装步骤\"></a>进入安装步骤</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>要进行安装的话需要先安装CMake，可以选择使用GUI 方式 或者命令行的方式。GUI可以在这里<a href=\"https://cmake.org/download/\" target=\"_blank\" rel=\"noopener\">下载</a>，命令行的方式的话，可以用brew来安装，方式如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install cmake</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装GLEW\"><a href=\"#安装GLEW\" class=\"headerlink\" title=\"安装GLEW\"></a>安装GLEW</h3><p>首先在这里下载<a href=\"http://glew.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">源码</a>，下载以后，解压文件，然后进入到文件所在路径，打开终端进入到此路径，执行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装GLFW\"><a href=\"#安装GLFW\" class=\"headerlink\" title=\"安装GLFW\"></a>安装GLFW</h3><p>首先在<a href=\"https://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">这里</a>下载源码，我们可以选择直接下载编译好的库，也可以下载源文件然后通过camke来自己编译，区别是如果用cmake库的话，在执行成功以后，会直接将生成的库与头文件分别添加到系统路径，也就是/usr/local/include和/usr/local/lib。这里就自己选择方式了。我在这里介绍利用make工具，自己编译的方式</p>\n<p>打开cmake 的gui工具，在source code选择下载的glfw路径，这一步需要在这个路径创建一个build目录，用于存放生成的文件。然后在browse build路径选择我们刚才创建的路径，点击configure。<br><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143441915-1128090430.png\" alt></p>\n<p>生成成功会出现如下效果</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143348522-1218740224.png\" alt></p>\n<p>接下来从终端进入到build目录，没错就是刚才我们创建的build，输入如下指令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，剩成的.a文件与头文件就都放到/usr/local/include和/usr/local/lib了。</p>\n<p>环境安装好以后，应该是这个样子的</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143328995-1467734221.png\" alt></p>\n<p>至此，环境安装完毕，接下来就是加入到工程了</p>\n<h2 id=\"加入工程\"><a href=\"#加入工程\" class=\"headerlink\" title=\"加入工程\"></a>加入工程</h2><h3 id=\"配置搜索路径\"><a href=\"#配置搜索路径\" class=\"headerlink\" title=\"配置搜索路径\"></a>配置搜索路径</h3><p>首先我们创建一个command line的工程，然后在build setting里这只user search path，在user search path中设置为：/usr/local/include，这里一定要注意不能选择递归查找，否则会出错。然后设置library search path为：/usr/local/lib。设置这个的作用是工程中明确工程中查找头文件和.a文件的路径。</p>\n<h3 id=\"添加要链接的framework\"><a href=\"#添加要链接的framework\" class=\"headerlink\" title=\"添加要链接的framework\"></a>添加要链接的framework</h3><p>添加以下库文件：</p>\n<ul>\n<li>Cocoa.framework</li>\n<li>OpenGL.framwork</li>\n<li>GLUT.framework</li>\n<li>CoreVideo.framework</li>\n<li>IOKit.framework</li>\n<li>libglfw3.a</li>\n<li>libGLEW.a</li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143224335-1252417188.png\" alt=\"库文件\"></p>\n<p>其中，libglfw3.a、libGLEW.a需要点击 add another，然后进入要路径/usr/local/lib中添加。</p>\n<p>配置完成以后，就可以写代码了，进入main.cpp文件，将main中修改如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;GL/glew.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Render</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glBegin(GL_TRIANGLES);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glColor3f(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">        glColor3f(<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">-.5</span>,<span class=\"number\">-.5</span>);</span><br><span class=\"line\">        glColor3f(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">.5</span>, <span class=\"number\">-.5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    GLFWwindow* win;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!glfwInit())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    win = glfwCreateWindow(<span class=\"number\">640</span>, <span class=\"number\">480</span>, <span class=\"string\">\"OpenGL Base Project\"</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!win)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glfwTerminate();</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!glewInit())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfwMakeContextCurrent(win);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!glfwWindowShouldClose(win))&#123;</span><br><span class=\"line\">        Render();</span><br><span class=\"line\">        glfwSwapBuffers(win);</span><br><span class=\"line\">        glfwPollEvents();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfwTerminate();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>见证奇迹的时刻到了，运行，你将会看到一个漂亮的三角形<img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143156518-737968913.png\" alt></p>\n<p>mac 工程搭建，就说这么多了。</p>\n<hr>\n<p>感谢以下文章的作者：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/24529016\" target=\"_blank\" rel=\"noopener\">Mac系统下配置OpenGL环境（小白自学版）</a></p>\n<p><a href=\"http://blog.shenyuanluo.com/OpenGLEnvironment.html\" target=\"_blank\" rel=\"noopener\">OpenGL学习笔记（二）—— (macOS)环境搭建</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MAC-OpenGL-环境搭建\"><a href=\"#MAC-OpenGL-环境搭建\" class=\"headerlink\" title=\"MAC OpenGL 环境搭建\"></a>MAC OpenGL 环境搭建</h1><h2 id=\"基础库介绍\"><a href=\"#基础库介绍\" class=\"headerlink\" title=\"基础库介绍\"></a>基础库介绍</h2><p>先要安装两个库一个是GLEW（OpenGL Extension Wrangler Library），另外一个是GLFW（Graphics Library Framework）</p>\n<h3 id=\"GLEW\"><a href=\"#GLEW\" class=\"headerlink\" title=\"GLEW\"></a>GLEW</h3><p>譯自英文-OpenGL擴展Wrangler庫是一個跨平台的C / C ++庫，可幫助查詢和加載OpenGL擴展。 GLEW提供了高效的運行時機制，用於確定目標平台上支持哪些OpenGL擴展。所有OpenGL擴展都在一個頭文件中公開，該文件是從官方擴展名列表機器生成的</p>\n<h3 id=\"GLFW\"><a href=\"#GLFW\" class=\"headerlink\" title=\"GLFW\"></a>GLFW</h3><p>GLFW 是配合 OpenGL 使用的轻量级工具程序库，缩写自 Graphics Library Framework（图形库框架）。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理手柄、键盘、鼠标输入的功能。</p>\n<h2 id=\"进入安装步骤\"><a href=\"#进入安装步骤\" class=\"headerlink\" title=\"进入安装步骤\"></a>进入安装步骤</h2><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>要进行安装的话需要先安装CMake，可以选择使用GUI 方式 或者命令行的方式。GUI可以在这里<a href=\"https://cmake.org/download/\" target=\"_blank\" rel=\"noopener\">下载</a>，命令行的方式的话，可以用brew来安装，方式如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install cmake</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装GLEW\"><a href=\"#安装GLEW\" class=\"headerlink\" title=\"安装GLEW\"></a>安装GLEW</h3><p>首先在这里下载<a href=\"http://glew.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">源码</a>，下载以后，解压文件，然后进入到文件所在路径，打开终端进入到此路径，执行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装GLFW\"><a href=\"#安装GLFW\" class=\"headerlink\" title=\"安装GLFW\"></a>安装GLFW</h3><p>首先在<a href=\"https://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">这里</a>下载源码，我们可以选择直接下载编译好的库，也可以下载源文件然后通过camke来自己编译，区别是如果用cmake库的话，在执行成功以后，会直接将生成的库与头文件分别添加到系统路径，也就是/usr/local/include和/usr/local/lib。这里就自己选择方式了。我在这里介绍利用make工具，自己编译的方式</p>\n<p>打开cmake 的gui工具，在source code选择下载的glfw路径，这一步需要在这个路径创建一个build目录，用于存放生成的文件。然后在browse build路径选择我们刚才创建的路径，点击configure。<br><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143441915-1128090430.png\" alt></p>\n<p>生成成功会出现如下效果</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143348522-1218740224.png\" alt></p>\n<p>接下来从终端进入到build目录，没错就是刚才我们创建的build，输入如下指令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，剩成的.a文件与头文件就都放到/usr/local/include和/usr/local/lib了。</p>\n<p>环境安装好以后，应该是这个样子的</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143328995-1467734221.png\" alt></p>\n<p>至此，环境安装完毕，接下来就是加入到工程了</p>\n<h2 id=\"加入工程\"><a href=\"#加入工程\" class=\"headerlink\" title=\"加入工程\"></a>加入工程</h2><h3 id=\"配置搜索路径\"><a href=\"#配置搜索路径\" class=\"headerlink\" title=\"配置搜索路径\"></a>配置搜索路径</h3><p>首先我们创建一个command line的工程，然后在build setting里这只user search path，在user search path中设置为：/usr/local/include，这里一定要注意不能选择递归查找，否则会出错。然后设置library search path为：/usr/local/lib。设置这个的作用是工程中明确工程中查找头文件和.a文件的路径。</p>\n<h3 id=\"添加要链接的framework\"><a href=\"#添加要链接的framework\" class=\"headerlink\" title=\"添加要链接的framework\"></a>添加要链接的framework</h3><p>添加以下库文件：</p>\n<ul>\n<li>Cocoa.framework</li>\n<li>OpenGL.framwork</li>\n<li>GLUT.framework</li>\n<li>CoreVideo.framework</li>\n<li>IOKit.framework</li>\n<li>libglfw3.a</li>\n<li>libGLEW.a</li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143224335-1252417188.png\" alt=\"库文件\"></p>\n<p>其中，libglfw3.a、libGLEW.a需要点击 add another，然后进入要路径/usr/local/lib中添加。</p>\n<p>配置完成以后，就可以写代码了，进入main.cpp文件，将main中修改如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;GL/glew.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Render</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    glClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glBegin(GL_TRIANGLES);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glColor3f(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">0</span>, <span class=\"number\">.5</span>);</span><br><span class=\"line\">        glColor3f(<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">-.5</span>,<span class=\"number\">-.5</span>);</span><br><span class=\"line\">        glColor3f(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">        glVertex2f(<span class=\"number\">.5</span>, <span class=\"number\">-.5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    GLFWwindow* win;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!glfwInit())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    win = glfwCreateWindow(<span class=\"number\">640</span>, <span class=\"number\">480</span>, <span class=\"string\">\"OpenGL Base Project\"</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!win)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glfwTerminate();</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!glewInit())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfwMakeContextCurrent(win);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!glfwWindowShouldClose(win))&#123;</span><br><span class=\"line\">        Render();</span><br><span class=\"line\">        glfwSwapBuffers(win);</span><br><span class=\"line\">        glfwPollEvents();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfwTerminate();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>见证奇迹的时刻到了，运行，你将会看到一个漂亮的三角形<img src=\"https://img2018.cnblogs.com/blog/552616/201908/552616-20190815143156518-737968913.png\" alt></p>\n<p>mac 工程搭建，就说这么多了。</p>\n<hr>\n<p>感谢以下文章的作者：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/24529016\" target=\"_blank\" rel=\"noopener\">Mac系统下配置OpenGL环境（小白自学版）</a></p>\n<p><a href=\"http://blog.shenyuanluo.com/OpenGLEnvironment.html\" target=\"_blank\" rel=\"noopener\">OpenGL学习笔记（二）—— (macOS)环境搭建</a></p>\n"},{"title":"TCP的三次握手与四次挥手","date":"2019-09-02T14:08:36.000Z","typora-root-url":"../../source","_content":"\n# 引言\n\n前段时间一直在准备面试，本以为准备的挺好，然而被腾讯面试官问道网络问题的时候，发现自己对TCP协议的理解真的是停留在表面，不够深入。于是本着提高自己的想法，去查了些资料，这里主要是总结我对TCP建立与断开连接过程的理解。\n\n# 常见题目\n\n在面试中网络问题是一定会考察的，而TCP协议则是考察网络知识的重点。经常会被问道的问题如下：\n\n1. 请讲一下TCP协议建立连接的过程\n2. 请介绍TCP协议中的三次握手和四次挥手是怎么样的\n3. 为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\n4. TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\n\n接下来，我将介绍我理解的TCP三次握手和4次挥手的过程，如果错误还请指正，谢谢。\n\n# TCP协议\n\n## 三次握手过程\n\n首先需要服务器监听特定的端口，等待客户端来请求连接。当客户端需要建立连接时，客户端会先向服务器发送syn报文，将报文中syn置为随机生成的序号n（这里假设序号为1000）。服务器收到同步报文后，会回复一个ack报文，把ACK位置位n+1（这里的序号应该为1001），同时设置syn为y（这里假设为2000）。客户端收到服务器发送的ack报文后，会回复一个ACK报文给服务器，其中ACK位置为y+1（这里即为2001）。当服务器收到ACK消息后，即认为连接进入稳定状态。状态机与流程图如下：\n\n![](/images/state_machine.png)\n\n\n![](/images/tcp3waysynch.png)\n\n## 四次挥手过程\n\n当client从app接收到关闭指令后，client会给server发送FIN消息（表明client不会再给server发送数据），client进入finish-wait-1状态。server收到finish消息后，回复确认消息ack给client，自身进入close-wait状态。client接收到ack消息后，进入到FIN-WAIT-2状态。并且在此状态等待服务器发送finish消息。当server接收到app的关闭指令后，server给client发送FIN消息。服务器进入到LAST-ACK状态。客户端收到FIN消息后，会回复ACK消息，同时进入到TIME-WAIT状态，来等待server收到ack消息，客户端会在接下来的2MSL（maximum segment lifetime）的时间内保持TIME-WAIT状态。为什么是2MSL时间呢，一是为了server有足够的时间收到ACK消息，并在消息丢失时重发。二是为了在此连接结束后的后续连接提供缓冲期。如果不是2倍MSL的话，就可能混合来自不同连接的数据包，造成消息混乱。状态机与流程图如下：\n\n![](/images/tcp_close_state_machine.png)\n\n![](/images/tcpclose1.png)\n\n## 完整过程\n\n以下为TCP从建立连接到断开的完整流程图\n\n![](/images/tcpfsm1.png)\n\n# 开始答题\n\n有了上面的介绍，基本能够回答前两个问题。\n\n### 请讲一下TCP协议建立连接的过程\n\n看上面\n\n### 请介绍TCP协议中的三次握手和四次挥手是怎么样的\n\n看上面\n\n### 为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\n\n首先呢，根本不存在可靠的连接，tcp只是提供相对可靠的连接。三次握手的主要目的是交换通信需要的参数，主要是server与client的syn序号，这个序号是用于收发数据的。如果只有两次握手的话，当服务器发送ack+syn消息后，就会认为建立了稳定连接，这个时候如果ack+syn丢失了，client并没有收到这个消息，那么客户端就会认为连接建立不成功，而直接进入close状态。这样就会造成，server一直在哪傻等，永远不会有client来发送数据，这就会造成服务器资源的浪费。至于为什么不是四次握手，是因为握手三次成功以后，就可以认定当前连接是可靠的了，不然的话还需要client与server互相之间发送ack消息，这样就无休无止了。\n\n### TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\n\n因为现实中的网络状况不可预知，比如说客户端在第一次连接时，使用序号为1为初始序号进行数据发送，发送了1到30的数据片段，这个时候因为网络问题断开了连接。然后客户端是syn为1重新建立了新的连接，这个时候服务器收到了之前发送的30个字节的数据，服务器就会以为这30个字节的数据是新发的，这就会导致数据混乱。\n\n# 参考资料\n\n说明，本文所有图片均来自[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm)。\n\n参考资料如下：\n\n[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm)\n\n[TCP为什么需要3次握手与4次挥手](https://blog.csdn.net/xifeijian/article/details/12777187)\n\n[TCP三次握手四次挥手详解](https://zhuanlan.zhihu.com/p/40013850)","source":"_posts/TCP的三次握手与四次挥手.md","raw":"---\ntitle: TCP的三次握手与四次挥手\ndate: 2019-09-02 14:08:36\ncategories:\n- [net]\ntypora-root-url: ../../source\n---\n\n# 引言\n\n前段时间一直在准备面试，本以为准备的挺好，然而被腾讯面试官问道网络问题的时候，发现自己对TCP协议的理解真的是停留在表面，不够深入。于是本着提高自己的想法，去查了些资料，这里主要是总结我对TCP建立与断开连接过程的理解。\n\n# 常见题目\n\n在面试中网络问题是一定会考察的，而TCP协议则是考察网络知识的重点。经常会被问道的问题如下：\n\n1. 请讲一下TCP协议建立连接的过程\n2. 请介绍TCP协议中的三次握手和四次挥手是怎么样的\n3. 为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\n4. TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\n\n接下来，我将介绍我理解的TCP三次握手和4次挥手的过程，如果错误还请指正，谢谢。\n\n# TCP协议\n\n## 三次握手过程\n\n首先需要服务器监听特定的端口，等待客户端来请求连接。当客户端需要建立连接时，客户端会先向服务器发送syn报文，将报文中syn置为随机生成的序号n（这里假设序号为1000）。服务器收到同步报文后，会回复一个ack报文，把ACK位置位n+1（这里的序号应该为1001），同时设置syn为y（这里假设为2000）。客户端收到服务器发送的ack报文后，会回复一个ACK报文给服务器，其中ACK位置为y+1（这里即为2001）。当服务器收到ACK消息后，即认为连接进入稳定状态。状态机与流程图如下：\n\n![](/images/state_machine.png)\n\n\n![](/images/tcp3waysynch.png)\n\n## 四次挥手过程\n\n当client从app接收到关闭指令后，client会给server发送FIN消息（表明client不会再给server发送数据），client进入finish-wait-1状态。server收到finish消息后，回复确认消息ack给client，自身进入close-wait状态。client接收到ack消息后，进入到FIN-WAIT-2状态。并且在此状态等待服务器发送finish消息。当server接收到app的关闭指令后，server给client发送FIN消息。服务器进入到LAST-ACK状态。客户端收到FIN消息后，会回复ACK消息，同时进入到TIME-WAIT状态，来等待server收到ack消息，客户端会在接下来的2MSL（maximum segment lifetime）的时间内保持TIME-WAIT状态。为什么是2MSL时间呢，一是为了server有足够的时间收到ACK消息，并在消息丢失时重发。二是为了在此连接结束后的后续连接提供缓冲期。如果不是2倍MSL的话，就可能混合来自不同连接的数据包，造成消息混乱。状态机与流程图如下：\n\n![](/images/tcp_close_state_machine.png)\n\n![](/images/tcpclose1.png)\n\n## 完整过程\n\n以下为TCP从建立连接到断开的完整流程图\n\n![](/images/tcpfsm1.png)\n\n# 开始答题\n\n有了上面的介绍，基本能够回答前两个问题。\n\n### 请讲一下TCP协议建立连接的过程\n\n看上面\n\n### 请介绍TCP协议中的三次握手和四次挥手是怎么样的\n\n看上面\n\n### 为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\n\n首先呢，根本不存在可靠的连接，tcp只是提供相对可靠的连接。三次握手的主要目的是交换通信需要的参数，主要是server与client的syn序号，这个序号是用于收发数据的。如果只有两次握手的话，当服务器发送ack+syn消息后，就会认为建立了稳定连接，这个时候如果ack+syn丢失了，client并没有收到这个消息，那么客户端就会认为连接建立不成功，而直接进入close状态。这样就会造成，server一直在哪傻等，永远不会有client来发送数据，这就会造成服务器资源的浪费。至于为什么不是四次握手，是因为握手三次成功以后，就可以认定当前连接是可靠的了，不然的话还需要client与server互相之间发送ack消息，这样就无休无止了。\n\n### TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\n\n因为现实中的网络状况不可预知，比如说客户端在第一次连接时，使用序号为1为初始序号进行数据发送，发送了1到30的数据片段，这个时候因为网络问题断开了连接。然后客户端是syn为1重新建立了新的连接，这个时候服务器收到了之前发送的30个字节的数据，服务器就会以为这30个字节的数据是新发的，这就会导致数据混乱。\n\n# 参考资料\n\n说明，本文所有图片均来自[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm)。\n\n参考资料如下：\n\n[The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm)\n\n[TCP为什么需要3次握手与4次挥手](https://blog.csdn.net/xifeijian/article/details/12777187)\n\n[TCP三次握手四次挥手详解](https://zhuanlan.zhihu.com/p/40013850)","slug":"TCP的三次握手与四次挥手","published":1,"updated":"2019-09-04T03:36:40.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyukr0007oqs6u00kk6e3","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>前段时间一直在准备面试，本以为准备的挺好，然而被腾讯面试官问道网络问题的时候，发现自己对TCP协议的理解真的是停留在表面，不够深入。于是本着提高自己的想法，去查了些资料，这里主要是总结我对TCP建立与断开连接过程的理解。</p>\n<h1 id=\"常见题目\"><a href=\"#常见题目\" class=\"headerlink\" title=\"常见题目\"></a>常见题目</h1><p>在面试中网络问题是一定会考察的，而TCP协议则是考察网络知识的重点。经常会被问道的问题如下：</p>\n<ol>\n<li>请讲一下TCP协议建立连接的过程</li>\n<li>请介绍TCP协议中的三次握手和四次挥手是怎么样的</li>\n<li>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</li>\n<li>TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1</li>\n</ol>\n<p>接下来，我将介绍我理解的TCP三次握手和4次挥手的过程，如果错误还请指正，谢谢。</p>\n<h1 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h1><h2 id=\"三次握手过程\"><a href=\"#三次握手过程\" class=\"headerlink\" title=\"三次握手过程\"></a>三次握手过程</h2><p>首先需要服务器监听特定的端口，等待客户端来请求连接。当客户端需要建立连接时，客户端会先向服务器发送syn报文，将报文中syn置为随机生成的序号n（这里假设序号为1000）。服务器收到同步报文后，会回复一个ack报文，把ACK位置位n+1（这里的序号应该为1001），同时设置syn为y（这里假设为2000）。客户端收到服务器发送的ack报文后，会回复一个ACK报文给服务器，其中ACK位置为y+1（这里即为2001）。当服务器收到ACK消息后，即认为连接进入稳定状态。状态机与流程图如下：</p>\n<p><img src=\"/images/state_machine.png\" alt></p>\n<p><img src=\"/images/tcp3waysynch.png\" alt></p>\n<h2 id=\"四次挥手过程\"><a href=\"#四次挥手过程\" class=\"headerlink\" title=\"四次挥手过程\"></a>四次挥手过程</h2><p>当client从app接收到关闭指令后，client会给server发送FIN消息（表明client不会再给server发送数据），client进入finish-wait-1状态。server收到finish消息后，回复确认消息ack给client，自身进入close-wait状态。client接收到ack消息后，进入到FIN-WAIT-2状态。并且在此状态等待服务器发送finish消息。当server接收到app的关闭指令后，server给client发送FIN消息。服务器进入到LAST-ACK状态。客户端收到FIN消息后，会回复ACK消息，同时进入到TIME-WAIT状态，来等待server收到ack消息，客户端会在接下来的2MSL（maximum segment lifetime）的时间内保持TIME-WAIT状态。为什么是2MSL时间呢，一是为了server有足够的时间收到ACK消息，并在消息丢失时重发。二是为了在此连接结束后的后续连接提供缓冲期。如果不是2倍MSL的话，就可能混合来自不同连接的数据包，造成消息混乱。状态机与流程图如下：</p>\n<p><img src=\"/images/tcp_close_state_machine.png\" alt></p>\n<p><img src=\"/images/tcpclose1.png\" alt></p>\n<h2 id=\"完整过程\"><a href=\"#完整过程\" class=\"headerlink\" title=\"完整过程\"></a>完整过程</h2><p>以下为TCP从建立连接到断开的完整流程图</p>\n<p><img src=\"/images/tcpfsm1.png\" alt></p>\n<h1 id=\"开始答题\"><a href=\"#开始答题\" class=\"headerlink\" title=\"开始答题\"></a>开始答题</h1><p>有了上面的介绍，基本能够回答前两个问题。</p>\n<h3 id=\"请讲一下TCP协议建立连接的过程\"><a href=\"#请讲一下TCP协议建立连接的过程\" class=\"headerlink\" title=\"请讲一下TCP协议建立连接的过程\"></a>请讲一下TCP协议建立连接的过程</h3><p>看上面</p>\n<h3 id=\"请介绍TCP协议中的三次握手和四次挥手是怎么样的\"><a href=\"#请介绍TCP协议中的三次握手和四次挥手是怎么样的\" class=\"headerlink\" title=\"请介绍TCP协议中的三次握手和四次挥手是怎么样的\"></a>请介绍TCP协议中的三次握手和四次挥手是怎么样的</h3><p>看上面</p>\n<h3 id=\"为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\"><a href=\"#为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\" class=\"headerlink\" title=\"为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\"></a>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</h3><p>首先呢，根本不存在可靠的连接，tcp只是提供相对可靠的连接。三次握手的主要目的是交换通信需要的参数，主要是server与client的syn序号，这个序号是用于收发数据的。如果只有两次握手的话，当服务器发送ack+syn消息后，就会认为建立了稳定连接，这个时候如果ack+syn丢失了，client并没有收到这个消息，那么客户端就会认为连接建立不成功，而直接进入close状态。这样就会造成，server一直在哪傻等，永远不会有client来发送数据，这就会造成服务器资源的浪费。至于为什么不是四次握手，是因为握手三次成功以后，就可以认定当前连接是可靠的了，不然的话还需要client与server互相之间发送ack消息，这样就无休无止了。</p>\n<h3 id=\"TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\"><a href=\"#TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\" class=\"headerlink\" title=\"TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\"></a>TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1</h3><p>因为现实中的网络状况不可预知，比如说客户端在第一次连接时，使用序号为1为初始序号进行数据发送，发送了1到30的数据片段，这个时候因为网络问题断开了连接。然后客户端是syn为1重新建立了新的连接，这个时候服务器收到了之前发送的30个字节的数据，服务器就会以为这30个字节的数据是新发的，这就会导致数据混乱。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>说明，本文所有图片均来自<a href=\"http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm\" target=\"_blank\" rel=\"noopener\">The TCP/IP Guide</a>。</p>\n<p>参考资料如下：</p>\n<p><a href=\"http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm\" target=\"_blank\" rel=\"noopener\">The TCP/IP Guide</a></p>\n<p><a href=\"https://blog.csdn.net/xifeijian/article/details/12777187\" target=\"_blank\" rel=\"noopener\">TCP为什么需要3次握手与4次挥手</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/40013850\" target=\"_blank\" rel=\"noopener\">TCP三次握手四次挥手详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>前段时间一直在准备面试，本以为准备的挺好，然而被腾讯面试官问道网络问题的时候，发现自己对TCP协议的理解真的是停留在表面，不够深入。于是本着提高自己的想法，去查了些资料，这里主要是总结我对TCP建立与断开连接过程的理解。</p>\n<h1 id=\"常见题目\"><a href=\"#常见题目\" class=\"headerlink\" title=\"常见题目\"></a>常见题目</h1><p>在面试中网络问题是一定会考察的，而TCP协议则是考察网络知识的重点。经常会被问道的问题如下：</p>\n<ol>\n<li>请讲一下TCP协议建立连接的过程</li>\n<li>请介绍TCP协议中的三次握手和四次挥手是怎么样的</li>\n<li>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</li>\n<li>TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1</li>\n</ol>\n<p>接下来，我将介绍我理解的TCP三次握手和4次挥手的过程，如果错误还请指正，谢谢。</p>\n<h1 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h1><h2 id=\"三次握手过程\"><a href=\"#三次握手过程\" class=\"headerlink\" title=\"三次握手过程\"></a>三次握手过程</h2><p>首先需要服务器监听特定的端口，等待客户端来请求连接。当客户端需要建立连接时，客户端会先向服务器发送syn报文，将报文中syn置为随机生成的序号n（这里假设序号为1000）。服务器收到同步报文后，会回复一个ack报文，把ACK位置位n+1（这里的序号应该为1001），同时设置syn为y（这里假设为2000）。客户端收到服务器发送的ack报文后，会回复一个ACK报文给服务器，其中ACK位置为y+1（这里即为2001）。当服务器收到ACK消息后，即认为连接进入稳定状态。状态机与流程图如下：</p>\n<p><img src=\"/images/state_machine.png\" alt></p>\n<p><img src=\"/images/tcp3waysynch.png\" alt></p>\n<h2 id=\"四次挥手过程\"><a href=\"#四次挥手过程\" class=\"headerlink\" title=\"四次挥手过程\"></a>四次挥手过程</h2><p>当client从app接收到关闭指令后，client会给server发送FIN消息（表明client不会再给server发送数据），client进入finish-wait-1状态。server收到finish消息后，回复确认消息ack给client，自身进入close-wait状态。client接收到ack消息后，进入到FIN-WAIT-2状态。并且在此状态等待服务器发送finish消息。当server接收到app的关闭指令后，server给client发送FIN消息。服务器进入到LAST-ACK状态。客户端收到FIN消息后，会回复ACK消息，同时进入到TIME-WAIT状态，来等待server收到ack消息，客户端会在接下来的2MSL（maximum segment lifetime）的时间内保持TIME-WAIT状态。为什么是2MSL时间呢，一是为了server有足够的时间收到ACK消息，并在消息丢失时重发。二是为了在此连接结束后的后续连接提供缓冲期。如果不是2倍MSL的话，就可能混合来自不同连接的数据包，造成消息混乱。状态机与流程图如下：</p>\n<p><img src=\"/images/tcp_close_state_machine.png\" alt></p>\n<p><img src=\"/images/tcpclose1.png\" alt></p>\n<h2 id=\"完整过程\"><a href=\"#完整过程\" class=\"headerlink\" title=\"完整过程\"></a>完整过程</h2><p>以下为TCP从建立连接到断开的完整流程图</p>\n<p><img src=\"/images/tcpfsm1.png\" alt></p>\n<h1 id=\"开始答题\"><a href=\"#开始答题\" class=\"headerlink\" title=\"开始答题\"></a>开始答题</h1><p>有了上面的介绍，基本能够回答前两个问题。</p>\n<h3 id=\"请讲一下TCP协议建立连接的过程\"><a href=\"#请讲一下TCP协议建立连接的过程\" class=\"headerlink\" title=\"请讲一下TCP协议建立连接的过程\"></a>请讲一下TCP协议建立连接的过程</h3><p>看上面</p>\n<h3 id=\"请介绍TCP协议中的三次握手和四次挥手是怎么样的\"><a href=\"#请介绍TCP协议中的三次握手和四次挥手是怎么样的\" class=\"headerlink\" title=\"请介绍TCP协议中的三次握手和四次挥手是怎么样的\"></a>请介绍TCP协议中的三次握手和四次挥手是怎么样的</h3><p>看上面</p>\n<h3 id=\"为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\"><a href=\"#为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\" class=\"headerlink\" title=\"为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次\"></a>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</h3><p>首先呢，根本不存在可靠的连接，tcp只是提供相对可靠的连接。三次握手的主要目的是交换通信需要的参数，主要是server与client的syn序号，这个序号是用于收发数据的。如果只有两次握手的话，当服务器发送ack+syn消息后，就会认为建立了稳定连接，这个时候如果ack+syn丢失了，client并没有收到这个消息，那么客户端就会认为连接建立不成功，而直接进入close状态。这样就会造成，server一直在哪傻等，永远不会有client来发送数据，这就会造成服务器资源的浪费。至于为什么不是四次握手，是因为握手三次成功以后，就可以认定当前连接是可靠的了，不然的话还需要client与server互相之间发送ack消息，这样就无休无止了。</p>\n<h3 id=\"TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\"><a href=\"#TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\" class=\"headerlink\" title=\"TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1\"></a>TCP连接发起是的syn序号为什么不能从同一个序号开始，比如说1</h3><p>因为现实中的网络状况不可预知，比如说客户端在第一次连接时，使用序号为1为初始序号进行数据发送，发送了1到30的数据片段，这个时候因为网络问题断开了连接。然后客户端是syn为1重新建立了新的连接，这个时候服务器收到了之前发送的30个字节的数据，服务器就会以为这30个字节的数据是新发的，这就会导致数据混乱。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>说明，本文所有图片均来自<a href=\"http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm\" target=\"_blank\" rel=\"noopener\">The TCP/IP Guide</a>。</p>\n<p>参考资料如下：</p>\n<p><a href=\"http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm\" target=\"_blank\" rel=\"noopener\">The TCP/IP Guide</a></p>\n<p><a href=\"https://blog.csdn.net/xifeijian/article/details/12777187\" target=\"_blank\" rel=\"noopener\">TCP为什么需要3次握手与4次挥手</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/40013850\" target=\"_blank\" rel=\"noopener\">TCP三次握手四次挥手详解</a></p>\n"},{"title":"iOS RGBA转YV12","date":"2019-10-16T16:58:23.000Z","typora-root-url":"../../source","_content":"\n# 引言\n\n因为项目中要做画面共享，所以需要学一点图像相关的知识，首当其冲就是RGB转YUV了，因为图像处理压缩这一块是由专业对口的同事做的，所以呢，我这就是写一下自己的理解，如有不对的地方，还望指正，谢谢。\n\n# 正文\n\n## 知识准备\n\n### RGB\n\n**三原色光模式**（**RGB color model**），又称**RGB颜色模型**或**红绿蓝颜色模型**，是一种[加色模型](https://zh.wikipedia.org/wiki/加色法)，将[红](https://zh.wikipedia.org/wiki/红)（**R**ed）、[绿](https://zh.wikipedia.org/wiki/绿色)（**G**reen）、[蓝](https://zh.wikipedia.org/wiki/蓝)（**B**lue）三[原色](https://zh.wikipedia.org/wiki/原色)的色光以不同的比例相加，以合成产生各种色彩光。\n\n### RGB32\n\nRGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha[通道](https://baike.baidu.com/item/通道)或者不用。（ARGB32就是带Alpha通道的RGB24。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：\n\n```c\ntypedef struct tagRGBQUAD {\nBYTE rgbBlue; // 蓝色分量\nBYTE rgbGreen; // 绿色分量\nBYTE rgbRed; // 红色分量\nBYTE rgbReserved; // 保留字节（用作Alpha通道或忽略）\n} RGBQUAD。\n```\n\n### YUV\n\n**YUV**，是一种[颜色](https://zh.wikipedia.org/wiki/顏色)[编码](https://zh.wikipedia.org/wiki/編碼)方法。常使用在各个影像处理组件中。 YUV在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。\n\nYUV是编译true-color颜色空间（color space）的种类，Y'UV, YUV, [YCbCr](https://zh.wikipedia.org/wiki/YCbCr)，[YPbPr](https://zh.wikipedia.org/wiki/YPbPr)等专有名词都可以称为YUV，彼此有重叠。“Y”表示**明亮度**（Luminance、Luma），“U”和“V”则是**色度**、**浓度**（Chrominance、Chroma）。\n\nYUV Formats分成两个格式：\n\n- 紧缩格式（packed formats）：将Y、U、V值存储成Macro Pixels数组，和[RGB](https://zh.wikipedia.org/wiki/RGB)的存放方式类似。\n- 平面格式（planar formats）：将Y、U、V的三个分量分别存放在不同的矩阵中。\n\n### YV12\n\nYV12是每个像素都提取Y，在UV提取时，将图像2 x 2的矩阵，每个矩阵提取一个U和一个V。YV12格式和I420格式的不同处在V平面和U平面的位置不同。在YV12格式中，V平面紧跟在Y平面之后，然后才是U平面（即：YVU）；但I420则是相反（即：YUV）。**NV12**与YV12类似，效果一样，YV12中U和V是连续排列的，而在NV12中，U和V就交错排列的。\n\n排列举例： **2\\*2图像**YYYYVU； **4＊4图像**YYYYYYYYYYYYYYYYVVVVUUUU。\n\nps：以上介绍摘自于维基百科、百度百科。\n\n## 进入正题\n\n### 获取RGBA数据\n\n在这里主要介绍从Image中获取RGBA数据，会用到CoreGraphics库。\n\n首先我们需要创建bitmap context\n\n```objc\n+ (CGContextRef) newBitmapRGBA8ContextFromImage:(CGImageRef) image {\n\tCGContextRef context = NULL;\n\tCGColorSpaceRef colorSpace;\n\tuint32_t *bitmapData;\n\t\n\tsize_t bitsPerPixel = 32; //每一个像素 由4个通道构成(RGBA)，每一个通道都是1个byte，4个通道也就是32个bit\n\tsize_t bitsPerComponent = 8; //可以理解为每个通道的bit数\n\tsize_t bytesPerPixel = bitsPerPixel / bitsPerComponent; //每个像素点的byte大小\n\t\n\tsize_t width = CGImageGetWidth(image); \n\tsize_t height = CGImageGetHeight(image);\n\t\n\tsize_t bytesPerRow = width * bytesPerPixel; //每一行的字节数\n\tsize_t bufferLength = bytesPerRow * height; //整个buffer的size\n\t\n\tcolorSpace = CGColorSpaceCreateDeviceRGB(); //指定颜色空间为RGB\n\t\n\tif(!colorSpace) {\n\t\tNSLog(@\"Error allocating color space RGB\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t// 开辟存储位图的内存\n\tbitmapData = (uint32_t *)malloc(bufferLength);\n\t\n\tif(!bitmapData) {\n\t\tNSLog(@\"Error allocating memory for bitmap\\n\");\n\t\tCGColorSpaceRelease(colorSpace);\n\t\treturn NULL;\n\t}\n\t\n\t// 创建bitmap context\n\tcontext = CGBitmapContextCreate(bitmapData, \n\t\t\t\t\t\t\t\t\twidth, \n\t\t\t\t\t\t\t\t\theight, \n\t\t\t\t\t\t\t\t\tbitsPerComponent, \n\t\t\t\t\t\t\t\t\tbytesPerRow, \n\t\t\t\t\t\t\t\t\tcolorSpace, \n                                    kCGImageAlphaPremultipliedLast);\t// RGBA\n\t\n\tif(!context) {\n        free(bitmapData);\n        NSLog(@\"Bitmap context not created\");\n    }\n    \n  CGColorSpaceRelease(colorSpace);\n\treturn context;\t\n}\n```\n\n接下来需要向image绘制到bitmap context，然后从context中获取bitmap data。代码如下：\n\n```objc\n+ (unsigned char *) convertUIImageToBitmapRGBA8:(UIImage *) image {\n\t\n\tCGImageRef imageRef = image.CGImage;\n\t\n\t// 创建bitmap context\n\tCGContextRef context = [self newBitmapRGBA8ContextFromImage:imageRef];\n\t\n\tif(!context) {\n\t\treturn NULL;\n\t}\n\t\n\tsize_t width = CGImageGetWidth(imageRef);\n\tsize_t height = CGImageGetHeight(imageRef);\n\t\n\tCGRect rect = CGRectMake(0, 0, width, height);\n\t\n\t// 将image绘制到bitmap context\n\tCGContextDrawImage(context, rect, imageRef);\n\t\n\t// 获取bitmap context\t中的数据指针\n\tunsigned char *bitmapData = (unsigned char *)CGBitmapContextGetData(context);\n\t\n\t// 拷贝 bitmap text中的数据\n\tsize_t bytesPerRow = CGBitmapContextGetBytesPerRow(context);\n\tsize_t bufferLength = bytesPerRow * height;\n\t\n\tunsigned char *newBitmap = NULL;\n\t\n\tif(bitmapData) {\n\t\tnewBitmap = (unsigned char *)malloc(sizeof(unsigned char) * bytesPerRow * height);\n\t\t\n\t\tif(newBitmap) {\t// 拷贝数据\n\t\t\tmemcpy(newBitmap, bitmapData, bufferLength);\n\t\t}\n\t\t\n\t\tfree(bitmapData);\n\t\t\n\t} else {\n\t\tNSLog(@\"Error getting bitmap pixel data\\n\");\n\t}\n\t\n\tCGContextRelease(context);\n\t\n\treturn newBitmap;\t\n}\n```\n\n看了这段代码，你可能会有疑问，为什么不直接返回bitmapData呢？这是因为在我们释放bitmap context后，会释放掉bitmapData，所以这就需要我们从新申请空间将数据拷贝到重新开辟的空间了。\n\n### 格式化图像数据\n\n因为YV12要求以像素的2 * 2矩阵来做转换，所以在做RGB转换YV12之前，我们需要先格式化图像数据，以满足要求。\n\n首先需要格式化图片size，在这里我们以8来对齐，代码如下：\n\n```objective-c\n+ (CGSize)fromatImageSizeToYV12Size:(CGSize)originalSize\n{\n    CGSize targetSize = CGSizeMake(originalSize.width, originalSize.height);\n    \n    //除以8是为了位对齐\n    int widthRemainder = (int)originalSize.width % 8;\n    \n    if (widthRemainder != 0) {\n        targetSize.width -= widthRemainder;\n    }\n    \n    int heightRemainder = (int)originalSize.height % 8;\n    if (heightRemainder != 0) {\n        targetSize.height -= heightRemainder;\n    }\n    \n    return targetSize;\n}\n```\n\n在上个步骤我们计算得到了满足YV12格式的size，在这里还需要根据计算到的size来格式化image data，以满足YV12格式要求，代码如下：\n\n```objc\n+ (void)formatImageDataToYV12:(unsigned char *)originalData outputData:(unsigned char *)outputData originalWidth:(CGFloat)originalWidth targetSize:(CGSize)targetSize\n{\n    CGFloat targetHeight = targetSize.height;\n    CGFloat targetWidth = targetSize.width;\n    \n    unsigned char *pTemp = outputData;\n    \n    //按照targetSize逐行拷贝数据, 乘以4是因为每个size表示4个通道\n    for (int i = 0; i < targetHeight; i++) {\n        memcpy(pTemp, originalData, targetWidth * 4);\n        originalData += (int)originalWidth * 4;\n        pTemp += (int)targetWidth * 4;\n    }\n}\n```\n\n数据准备好了，接下来，可以进入真正的主题，RGBA转换为YV12了。\n\n### RGBA转YV12\n\n对于RGB转换为对应的YV12，转换规则都是大佬们研究出来的，只是实现的方式各有不同，我在这里罗列了我找到的几种方式。\n\n```objc\nvoid rgb2yuv(int r, int g, int b, int *y, int *u, int *v){\n    // 1 常规转换标准 - 浮点运算，精度高\n    *y =  0.29882  * r + 0.58681  * g + 0.114363 * b;\n    *u = -0.172485 * r - 0.338718 * g + 0.511207 * b;\n    *v =  0.51155  * r - 0.42811  * g - 0.08343  * b;\n\n    // 2 常规转换标准 通过位移来避免浮点运算，精度低\n    *y = ( 76  * r + 150 * g + 29  * b)>>8;\n    *u = (-44  * r - 87  * g + 131 * b)>>8;\n    *v = ( 131 * r - 110 * g - 21  * b)>>8;\n    // 3 常规转换标准 通过位移来避免乘法运算，精度低\n    *y = ( (r<<6) + (r<<3) + (r<<2) + (g<<7) + (g<<4) + (g<<2) + (g<<1) + (b<<4) + (b<<3) + (b<<2) + b)>>8;\n    *u = (-(r<<5) - (r<<3) - (r<<2) - (g<<6) - (g<<4) - (g<<2) - (g<<1) - g + (b<<7) + (b<<1) + b)>>8;\n    *v = ((r<<7) + (r<<1) + r - (g<<6) - (g<<5) - (g<<3) - (g<<2) - (g<<1) - (b<<4) - (b<<2) - b)>>8;\n    \n    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高\n    *y =  0.2126  * r + 0.7152  * g + 0.0722  * b;\n    *u = -0.09991 * r - 0.33609 * g + 0.436   * b;\n    *v =  0.615   * r - 0.55861 * g - 0.05639 * b;\n    \n    *v += 128;\n    *u += 128;\n}\n```\n\n以上的转换方式都是可行的，当然要提升效率的话，还有查表法什么的，这些有兴趣的可以自行搜索。既然转换规则固定了，那么不考虑效率的前提下，我们需要做的就是如何从rgba数组中按照2 * 2矩阵来获取YUV数据并存储下来了。\n\n在这里介绍采用紧缩格式存储YV12的数据。为了便于理解，在这里先举个栗子：\n\n下图中的表示一张图中的像素排列，每个像素都包含RGBA通道，将RGBA转换为YV12需要按照2 * 2的像素矩阵为单位来处理，在图中就是按颜色分块中的像素来获取YUV数据，YV12是每4个像素获取一次U、V分量的数据，每个像素都要获取Y分量。\n\n![](/images/rgb2yuv.png)\n\n要看转换后的YUV的样子，这里以2 * 2为例，8 个像素生成的YUV如下：\n\n```text\nYYYY YYYY VV UU \n```\n\n有了上面的知识，就可以直接上代码看看了。在这里我们以数组的方式来存储yuv数据，输入的rgba数据我们设置为int型数组，因为每个像素包含4个通道，每个通道都是一个byte，这样每个像素是4个byte，正好是一个int。需要注意的是，在int数组中，按理说每个int的数据应该是:RGBA，但是在iOS上，由于iOS是小端，所以实际上每个int的内容为ABGR，所以在取数据的时候需要注意，避免弄错顺序。还有需要注意的是，计算出来的UV数据需要避免负数，不然颜色值会有问题。\n\n```objc\nvoid rgbaConvert2YV12(int *rgbData, uint8_t *yuv, int width, int height) {\n    int frameSize = width * height;\n    int yIndex = 0;\n    int vIndex = frameSize;\n    int uIndex = frameSize * 1.25;\n\n    int R, G, B, Y, U, V, A;\n    int index = 0;\n    for (int j = 0; j < height; j++) {\n        for (int i = 0; i < width; i++) {//RGBA\n            //样式为ABGR iOS设备为小端\n            A = (rgbData[index] >> 24) & 0xff;\n            B = (rgbData[index] >> 16) & 0xff;\n            G = (rgbData[index] >> 8) & 0xff;\n            R = rgbData[index] & 0xff;\n            \n            //转换\n            rgb2yuv(R, G, B, &Y, &U, &V);\n            //避免负数\n            U += 128;\n            V += 128;\n            \n            Y = RANG_CONTROL(Y, 0, 255);\n            U = RANG_CONTROL(U, 0, 255);\n            V = RANG_CONTROL(V, 0, 255);\n            \n            yuv[yIndex++] = Y;\n            \n            if (j % 2 == 0 && i % 2 == 0) {//按2 * 2矩阵取\n                yuv[vIndex++] = V;\n                yuv[uIndex++] = U;\n            }\n            index ++;\n        }\n    }\n}\n```\n\n### YV12转RGBA\n\n首先还是yuv转rgb的方法，这与RGB转YV12是对应的。\n\n```\nvoid yuv2rgb(int y, int u, int v, int *r, int *g, int *b){\n    u -= 128;\n    v -= 128;\n    // 1 常规转换标准 - 浮点运算，精度高\n    *r = y                  + (1.370705 * v);\n    *g = y - (0.337633 * u) - (0.698001 * v);\n    *b = y + (1.732446 * u);\n\n    // 2 常规转换标准 通过位移来避免浮点运算，精度低\n    *r = ((256 * y             + (351 * v))>>8);\n    *g = ((256 * y - (86  * u) - (179 * v))>>8);\n    *b = ((256 * y + (444 * u))            >>8);\n    // 3 常规转换标准 通过位移来避免乘法运算，精度低\n    *r = (((y<<8) + (v<<8) + (v<<6) + (v<<4) + (v<<3) + (v<<2) + (v<<1) + v)                   >> 8);\n    *g = (((y<<8) - (u<<6) - (u<<4) - (u<<2) - (u<<1) - (v<<7) - (v<<5) - (v<<4) - (v<<1) - v) >> 8);\n    *b = (((y<<8) + (u<<8) + (u<<7) + (u<<5) + (u<<4) + (u<<3) + (u<<2))                       >> 8);\n    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高\n    *r = (y               + 1.28033 * v);\n    *g = (y - 0.21482 * u - 0.38059 * v);\n    *b = (y + 2.12798 * u);\n}\n```\n\n重点来了，将YUV数组恢复为RGBA数组\n\n```objc\nvoid YV12Convert2RGB(uint8_t *yuv, uint8_t *rgb, int width, int height){\n    int frameSize = width * height;\n    int rgbIndex = 0;\n    int yIndex = 0;\n    int uvOffset = 0;\n    int vIndex = frameSize;\n    int uIndex = frameSize * 1.25;\n    int R, G, B, Y, U, V;\n    \n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            Y = yuv[yIndex++];\n            uvOffset = i / 2 * width / 2 + j / 2;//按2 * 2矩阵 还原\n            \n            V = yuv[vIndex + uvOffset];\n            U = yuv[uIndex + uvOffset];\n            \n            yuv2rgb(Y, U, V, &R, &G, &B);\n            \n            R = RANG_CONTROL(R, 0, 255);\n            G = RANG_CONTROL(G, 0, 255);\n            B = RANG_CONTROL(B, 0, 255);\n            \n            rgb[rgbIndex++] = R;\n            rgb[rgbIndex++] = G;\n            rgb[rgbIndex++] = B;\n            rgb[rgbIndex++] = 255;\n        }\n    }\n}\n```\n\n以上就是iOS中RGB与YUV互转的方式了，你可以在[这里](https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F)下载demo\n\n# 参考\n\n[三元光模式-维基百科](https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F)\n\n[RGB百度百科](https://baike.baidu.com/item/RGB)\n\n[IOS rgb yuv 转换](https://blog.csdn.net/CAICHAO1234/article/details/79260954)\n\n[YUV和RGB互相转换及OpenGL显示YUV数据](http://anddymao.com/2017/12/04/2017-12-4-YUV%E5%92%8CRGB%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8AOpenGL%E6%98%BE%E7%A4%BAYUV%E6%95%B0%E6%8D%AE/)\n\n[YUV颜色编码解析](https://www.jianshu.com/p/a91502c00fb0)\n\n[YUV与RGB格式转化](https://www.cnblogs.com/dwdxdy/p/3713990.html)","source":"_posts/iOS-RGBA转YV12.md","raw":"---\ntitle: iOS RGBA转YV12\ndate: 2019-10-16 16:58:23\ncategories:\n- [sundry]\ntypora-root-url: ../../source\n---\n\n# 引言\n\n因为项目中要做画面共享，所以需要学一点图像相关的知识，首当其冲就是RGB转YUV了，因为图像处理压缩这一块是由专业对口的同事做的，所以呢，我这就是写一下自己的理解，如有不对的地方，还望指正，谢谢。\n\n# 正文\n\n## 知识准备\n\n### RGB\n\n**三原色光模式**（**RGB color model**），又称**RGB颜色模型**或**红绿蓝颜色模型**，是一种[加色模型](https://zh.wikipedia.org/wiki/加色法)，将[红](https://zh.wikipedia.org/wiki/红)（**R**ed）、[绿](https://zh.wikipedia.org/wiki/绿色)（**G**reen）、[蓝](https://zh.wikipedia.org/wiki/蓝)（**B**lue）三[原色](https://zh.wikipedia.org/wiki/原色)的色光以不同的比例相加，以合成产生各种色彩光。\n\n### RGB32\n\nRGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha[通道](https://baike.baidu.com/item/通道)或者不用。（ARGB32就是带Alpha通道的RGB24。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：\n\n```c\ntypedef struct tagRGBQUAD {\nBYTE rgbBlue; // 蓝色分量\nBYTE rgbGreen; // 绿色分量\nBYTE rgbRed; // 红色分量\nBYTE rgbReserved; // 保留字节（用作Alpha通道或忽略）\n} RGBQUAD。\n```\n\n### YUV\n\n**YUV**，是一种[颜色](https://zh.wikipedia.org/wiki/顏色)[编码](https://zh.wikipedia.org/wiki/編碼)方法。常使用在各个影像处理组件中。 YUV在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。\n\nYUV是编译true-color颜色空间（color space）的种类，Y'UV, YUV, [YCbCr](https://zh.wikipedia.org/wiki/YCbCr)，[YPbPr](https://zh.wikipedia.org/wiki/YPbPr)等专有名词都可以称为YUV，彼此有重叠。“Y”表示**明亮度**（Luminance、Luma），“U”和“V”则是**色度**、**浓度**（Chrominance、Chroma）。\n\nYUV Formats分成两个格式：\n\n- 紧缩格式（packed formats）：将Y、U、V值存储成Macro Pixels数组，和[RGB](https://zh.wikipedia.org/wiki/RGB)的存放方式类似。\n- 平面格式（planar formats）：将Y、U、V的三个分量分别存放在不同的矩阵中。\n\n### YV12\n\nYV12是每个像素都提取Y，在UV提取时，将图像2 x 2的矩阵，每个矩阵提取一个U和一个V。YV12格式和I420格式的不同处在V平面和U平面的位置不同。在YV12格式中，V平面紧跟在Y平面之后，然后才是U平面（即：YVU）；但I420则是相反（即：YUV）。**NV12**与YV12类似，效果一样，YV12中U和V是连续排列的，而在NV12中，U和V就交错排列的。\n\n排列举例： **2\\*2图像**YYYYVU； **4＊4图像**YYYYYYYYYYYYYYYYVVVVUUUU。\n\nps：以上介绍摘自于维基百科、百度百科。\n\n## 进入正题\n\n### 获取RGBA数据\n\n在这里主要介绍从Image中获取RGBA数据，会用到CoreGraphics库。\n\n首先我们需要创建bitmap context\n\n```objc\n+ (CGContextRef) newBitmapRGBA8ContextFromImage:(CGImageRef) image {\n\tCGContextRef context = NULL;\n\tCGColorSpaceRef colorSpace;\n\tuint32_t *bitmapData;\n\t\n\tsize_t bitsPerPixel = 32; //每一个像素 由4个通道构成(RGBA)，每一个通道都是1个byte，4个通道也就是32个bit\n\tsize_t bitsPerComponent = 8; //可以理解为每个通道的bit数\n\tsize_t bytesPerPixel = bitsPerPixel / bitsPerComponent; //每个像素点的byte大小\n\t\n\tsize_t width = CGImageGetWidth(image); \n\tsize_t height = CGImageGetHeight(image);\n\t\n\tsize_t bytesPerRow = width * bytesPerPixel; //每一行的字节数\n\tsize_t bufferLength = bytesPerRow * height; //整个buffer的size\n\t\n\tcolorSpace = CGColorSpaceCreateDeviceRGB(); //指定颜色空间为RGB\n\t\n\tif(!colorSpace) {\n\t\tNSLog(@\"Error allocating color space RGB\\n\");\n\t\treturn NULL;\n\t}\n\t\n\t// 开辟存储位图的内存\n\tbitmapData = (uint32_t *)malloc(bufferLength);\n\t\n\tif(!bitmapData) {\n\t\tNSLog(@\"Error allocating memory for bitmap\\n\");\n\t\tCGColorSpaceRelease(colorSpace);\n\t\treturn NULL;\n\t}\n\t\n\t// 创建bitmap context\n\tcontext = CGBitmapContextCreate(bitmapData, \n\t\t\t\t\t\t\t\t\twidth, \n\t\t\t\t\t\t\t\t\theight, \n\t\t\t\t\t\t\t\t\tbitsPerComponent, \n\t\t\t\t\t\t\t\t\tbytesPerRow, \n\t\t\t\t\t\t\t\t\tcolorSpace, \n                                    kCGImageAlphaPremultipliedLast);\t// RGBA\n\t\n\tif(!context) {\n        free(bitmapData);\n        NSLog(@\"Bitmap context not created\");\n    }\n    \n  CGColorSpaceRelease(colorSpace);\n\treturn context;\t\n}\n```\n\n接下来需要向image绘制到bitmap context，然后从context中获取bitmap data。代码如下：\n\n```objc\n+ (unsigned char *) convertUIImageToBitmapRGBA8:(UIImage *) image {\n\t\n\tCGImageRef imageRef = image.CGImage;\n\t\n\t// 创建bitmap context\n\tCGContextRef context = [self newBitmapRGBA8ContextFromImage:imageRef];\n\t\n\tif(!context) {\n\t\treturn NULL;\n\t}\n\t\n\tsize_t width = CGImageGetWidth(imageRef);\n\tsize_t height = CGImageGetHeight(imageRef);\n\t\n\tCGRect rect = CGRectMake(0, 0, width, height);\n\t\n\t// 将image绘制到bitmap context\n\tCGContextDrawImage(context, rect, imageRef);\n\t\n\t// 获取bitmap context\t中的数据指针\n\tunsigned char *bitmapData = (unsigned char *)CGBitmapContextGetData(context);\n\t\n\t// 拷贝 bitmap text中的数据\n\tsize_t bytesPerRow = CGBitmapContextGetBytesPerRow(context);\n\tsize_t bufferLength = bytesPerRow * height;\n\t\n\tunsigned char *newBitmap = NULL;\n\t\n\tif(bitmapData) {\n\t\tnewBitmap = (unsigned char *)malloc(sizeof(unsigned char) * bytesPerRow * height);\n\t\t\n\t\tif(newBitmap) {\t// 拷贝数据\n\t\t\tmemcpy(newBitmap, bitmapData, bufferLength);\n\t\t}\n\t\t\n\t\tfree(bitmapData);\n\t\t\n\t} else {\n\t\tNSLog(@\"Error getting bitmap pixel data\\n\");\n\t}\n\t\n\tCGContextRelease(context);\n\t\n\treturn newBitmap;\t\n}\n```\n\n看了这段代码，你可能会有疑问，为什么不直接返回bitmapData呢？这是因为在我们释放bitmap context后，会释放掉bitmapData，所以这就需要我们从新申请空间将数据拷贝到重新开辟的空间了。\n\n### 格式化图像数据\n\n因为YV12要求以像素的2 * 2矩阵来做转换，所以在做RGB转换YV12之前，我们需要先格式化图像数据，以满足要求。\n\n首先需要格式化图片size，在这里我们以8来对齐，代码如下：\n\n```objective-c\n+ (CGSize)fromatImageSizeToYV12Size:(CGSize)originalSize\n{\n    CGSize targetSize = CGSizeMake(originalSize.width, originalSize.height);\n    \n    //除以8是为了位对齐\n    int widthRemainder = (int)originalSize.width % 8;\n    \n    if (widthRemainder != 0) {\n        targetSize.width -= widthRemainder;\n    }\n    \n    int heightRemainder = (int)originalSize.height % 8;\n    if (heightRemainder != 0) {\n        targetSize.height -= heightRemainder;\n    }\n    \n    return targetSize;\n}\n```\n\n在上个步骤我们计算得到了满足YV12格式的size，在这里还需要根据计算到的size来格式化image data，以满足YV12格式要求，代码如下：\n\n```objc\n+ (void)formatImageDataToYV12:(unsigned char *)originalData outputData:(unsigned char *)outputData originalWidth:(CGFloat)originalWidth targetSize:(CGSize)targetSize\n{\n    CGFloat targetHeight = targetSize.height;\n    CGFloat targetWidth = targetSize.width;\n    \n    unsigned char *pTemp = outputData;\n    \n    //按照targetSize逐行拷贝数据, 乘以4是因为每个size表示4个通道\n    for (int i = 0; i < targetHeight; i++) {\n        memcpy(pTemp, originalData, targetWidth * 4);\n        originalData += (int)originalWidth * 4;\n        pTemp += (int)targetWidth * 4;\n    }\n}\n```\n\n数据准备好了，接下来，可以进入真正的主题，RGBA转换为YV12了。\n\n### RGBA转YV12\n\n对于RGB转换为对应的YV12，转换规则都是大佬们研究出来的，只是实现的方式各有不同，我在这里罗列了我找到的几种方式。\n\n```objc\nvoid rgb2yuv(int r, int g, int b, int *y, int *u, int *v){\n    // 1 常规转换标准 - 浮点运算，精度高\n    *y =  0.29882  * r + 0.58681  * g + 0.114363 * b;\n    *u = -0.172485 * r - 0.338718 * g + 0.511207 * b;\n    *v =  0.51155  * r - 0.42811  * g - 0.08343  * b;\n\n    // 2 常规转换标准 通过位移来避免浮点运算，精度低\n    *y = ( 76  * r + 150 * g + 29  * b)>>8;\n    *u = (-44  * r - 87  * g + 131 * b)>>8;\n    *v = ( 131 * r - 110 * g - 21  * b)>>8;\n    // 3 常规转换标准 通过位移来避免乘法运算，精度低\n    *y = ( (r<<6) + (r<<3) + (r<<2) + (g<<7) + (g<<4) + (g<<2) + (g<<1) + (b<<4) + (b<<3) + (b<<2) + b)>>8;\n    *u = (-(r<<5) - (r<<3) - (r<<2) - (g<<6) - (g<<4) - (g<<2) - (g<<1) - g + (b<<7) + (b<<1) + b)>>8;\n    *v = ((r<<7) + (r<<1) + r - (g<<6) - (g<<5) - (g<<3) - (g<<2) - (g<<1) - (b<<4) - (b<<2) - b)>>8;\n    \n    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高\n    *y =  0.2126  * r + 0.7152  * g + 0.0722  * b;\n    *u = -0.09991 * r - 0.33609 * g + 0.436   * b;\n    *v =  0.615   * r - 0.55861 * g - 0.05639 * b;\n    \n    *v += 128;\n    *u += 128;\n}\n```\n\n以上的转换方式都是可行的，当然要提升效率的话，还有查表法什么的，这些有兴趣的可以自行搜索。既然转换规则固定了，那么不考虑效率的前提下，我们需要做的就是如何从rgba数组中按照2 * 2矩阵来获取YUV数据并存储下来了。\n\n在这里介绍采用紧缩格式存储YV12的数据。为了便于理解，在这里先举个栗子：\n\n下图中的表示一张图中的像素排列，每个像素都包含RGBA通道，将RGBA转换为YV12需要按照2 * 2的像素矩阵为单位来处理，在图中就是按颜色分块中的像素来获取YUV数据，YV12是每4个像素获取一次U、V分量的数据，每个像素都要获取Y分量。\n\n![](/images/rgb2yuv.png)\n\n要看转换后的YUV的样子，这里以2 * 2为例，8 个像素生成的YUV如下：\n\n```text\nYYYY YYYY VV UU \n```\n\n有了上面的知识，就可以直接上代码看看了。在这里我们以数组的方式来存储yuv数据，输入的rgba数据我们设置为int型数组，因为每个像素包含4个通道，每个通道都是一个byte，这样每个像素是4个byte，正好是一个int。需要注意的是，在int数组中，按理说每个int的数据应该是:RGBA，但是在iOS上，由于iOS是小端，所以实际上每个int的内容为ABGR，所以在取数据的时候需要注意，避免弄错顺序。还有需要注意的是，计算出来的UV数据需要避免负数，不然颜色值会有问题。\n\n```objc\nvoid rgbaConvert2YV12(int *rgbData, uint8_t *yuv, int width, int height) {\n    int frameSize = width * height;\n    int yIndex = 0;\n    int vIndex = frameSize;\n    int uIndex = frameSize * 1.25;\n\n    int R, G, B, Y, U, V, A;\n    int index = 0;\n    for (int j = 0; j < height; j++) {\n        for (int i = 0; i < width; i++) {//RGBA\n            //样式为ABGR iOS设备为小端\n            A = (rgbData[index] >> 24) & 0xff;\n            B = (rgbData[index] >> 16) & 0xff;\n            G = (rgbData[index] >> 8) & 0xff;\n            R = rgbData[index] & 0xff;\n            \n            //转换\n            rgb2yuv(R, G, B, &Y, &U, &V);\n            //避免负数\n            U += 128;\n            V += 128;\n            \n            Y = RANG_CONTROL(Y, 0, 255);\n            U = RANG_CONTROL(U, 0, 255);\n            V = RANG_CONTROL(V, 0, 255);\n            \n            yuv[yIndex++] = Y;\n            \n            if (j % 2 == 0 && i % 2 == 0) {//按2 * 2矩阵取\n                yuv[vIndex++] = V;\n                yuv[uIndex++] = U;\n            }\n            index ++;\n        }\n    }\n}\n```\n\n### YV12转RGBA\n\n首先还是yuv转rgb的方法，这与RGB转YV12是对应的。\n\n```\nvoid yuv2rgb(int y, int u, int v, int *r, int *g, int *b){\n    u -= 128;\n    v -= 128;\n    // 1 常规转换标准 - 浮点运算，精度高\n    *r = y                  + (1.370705 * v);\n    *g = y - (0.337633 * u) - (0.698001 * v);\n    *b = y + (1.732446 * u);\n\n    // 2 常规转换标准 通过位移来避免浮点运算，精度低\n    *r = ((256 * y             + (351 * v))>>8);\n    *g = ((256 * y - (86  * u) - (179 * v))>>8);\n    *b = ((256 * y + (444 * u))            >>8);\n    // 3 常规转换标准 通过位移来避免乘法运算，精度低\n    *r = (((y<<8) + (v<<8) + (v<<6) + (v<<4) + (v<<3) + (v<<2) + (v<<1) + v)                   >> 8);\n    *g = (((y<<8) - (u<<6) - (u<<4) - (u<<2) - (u<<1) - (v<<7) - (v<<5) - (v<<4) - (v<<1) - v) >> 8);\n    *b = (((y<<8) + (u<<8) + (u<<7) + (u<<5) + (u<<4) + (u<<3) + (u<<2))                       >> 8);\n    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高\n    *r = (y               + 1.28033 * v);\n    *g = (y - 0.21482 * u - 0.38059 * v);\n    *b = (y + 2.12798 * u);\n}\n```\n\n重点来了，将YUV数组恢复为RGBA数组\n\n```objc\nvoid YV12Convert2RGB(uint8_t *yuv, uint8_t *rgb, int width, int height){\n    int frameSize = width * height;\n    int rgbIndex = 0;\n    int yIndex = 0;\n    int uvOffset = 0;\n    int vIndex = frameSize;\n    int uIndex = frameSize * 1.25;\n    int R, G, B, Y, U, V;\n    \n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            Y = yuv[yIndex++];\n            uvOffset = i / 2 * width / 2 + j / 2;//按2 * 2矩阵 还原\n            \n            V = yuv[vIndex + uvOffset];\n            U = yuv[uIndex + uvOffset];\n            \n            yuv2rgb(Y, U, V, &R, &G, &B);\n            \n            R = RANG_CONTROL(R, 0, 255);\n            G = RANG_CONTROL(G, 0, 255);\n            B = RANG_CONTROL(B, 0, 255);\n            \n            rgb[rgbIndex++] = R;\n            rgb[rgbIndex++] = G;\n            rgb[rgbIndex++] = B;\n            rgb[rgbIndex++] = 255;\n        }\n    }\n}\n```\n\n以上就是iOS中RGB与YUV互转的方式了，你可以在[这里](https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F)下载demo\n\n# 参考\n\n[三元光模式-维基百科](https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F)\n\n[RGB百度百科](https://baike.baidu.com/item/RGB)\n\n[IOS rgb yuv 转换](https://blog.csdn.net/CAICHAO1234/article/details/79260954)\n\n[YUV和RGB互相转换及OpenGL显示YUV数据](http://anddymao.com/2017/12/04/2017-12-4-YUV%E5%92%8CRGB%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8AOpenGL%E6%98%BE%E7%A4%BAYUV%E6%95%B0%E6%8D%AE/)\n\n[YUV颜色编码解析](https://www.jianshu.com/p/a91502c00fb0)\n\n[YUV与RGB格式转化](https://www.cnblogs.com/dwdxdy/p/3713990.html)","slug":"iOS-RGBA转YV12","published":1,"updated":"2019-10-17T10:01:04.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyukt0009oqs67ct0gcd9","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>因为项目中要做画面共享，所以需要学一点图像相关的知识，首当其冲就是RGB转YUV了，因为图像处理压缩这一块是由专业对口的同事做的，所以呢，我这就是写一下自己的理解，如有不对的地方，还望指正，谢谢。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"知识准备\"><a href=\"#知识准备\" class=\"headerlink\" title=\"知识准备\"></a>知识准备</h2><h3 id=\"RGB\"><a href=\"#RGB\" class=\"headerlink\" title=\"RGB\"></a>RGB</h3><p><strong>三原色光模式</strong>（<strong>RGB color model</strong>），又称<strong>RGB颜色模型</strong>或<strong>红绿蓝颜色模型</strong>，是一种<a href=\"https://zh.wikipedia.org/wiki/加色法\" target=\"_blank\" rel=\"noopener\">加色模型</a>，将<a href=\"https://zh.wikipedia.org/wiki/红\" target=\"_blank\" rel=\"noopener\">红</a>（<strong>R</strong>ed）、<a href=\"https://zh.wikipedia.org/wiki/绿色\" target=\"_blank\" rel=\"noopener\">绿</a>（<strong>G</strong>reen）、<a href=\"https://zh.wikipedia.org/wiki/蓝\" target=\"_blank\" rel=\"noopener\">蓝</a>（<strong>B</strong>lue）三<a href=\"https://zh.wikipedia.org/wiki/原色\" target=\"_blank\" rel=\"noopener\">原色</a>的色光以不同的比例相加，以合成产生各种色彩光。</p>\n<h3 id=\"RGB32\"><a href=\"#RGB32\" class=\"headerlink\" title=\"RGB32\"></a>RGB32</h3><p>RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha<a href=\"https://baike.baidu.com/item/通道\" target=\"_blank\" rel=\"noopener\">通道</a>或者不用。（ARGB32就是带Alpha通道的RGB24。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagRGBQUAD</span> &#123;</span></span><br><span class=\"line\">BYTE rgbBlue; <span class=\"comment\">// 蓝色分量</span></span><br><span class=\"line\">BYTE rgbGreen; <span class=\"comment\">// 绿色分量</span></span><br><span class=\"line\">BYTE rgbRed; <span class=\"comment\">// 红色分量</span></span><br><span class=\"line\">BYTE rgbReserved; <span class=\"comment\">// 保留字节（用作Alpha通道或忽略）</span></span><br><span class=\"line\">&#125; RGBQUAD。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"YUV\"><a href=\"#YUV\" class=\"headerlink\" title=\"YUV\"></a>YUV</h3><p><strong>YUV</strong>，是一种<a href=\"https://zh.wikipedia.org/wiki/顏色\" target=\"_blank\" rel=\"noopener\">颜色</a><a href=\"https://zh.wikipedia.org/wiki/編碼\" target=\"_blank\" rel=\"noopener\">编码</a>方法。常使用在各个影像处理组件中。 YUV在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。</p>\n<p>YUV是编译true-color颜色空间（color space）的种类，Y’UV, YUV, <a href=\"https://zh.wikipedia.org/wiki/YCbCr\" target=\"_blank\" rel=\"noopener\">YCbCr</a>，<a href=\"https://zh.wikipedia.org/wiki/YPbPr\" target=\"_blank\" rel=\"noopener\">YPbPr</a>等专有名词都可以称为YUV，彼此有重叠。“Y”表示<strong>明亮度</strong>（Luminance、Luma），“U”和“V”则是<strong>色度</strong>、<strong>浓度</strong>（Chrominance、Chroma）。</p>\n<p>YUV Formats分成两个格式：</p>\n<ul>\n<li>紧缩格式（packed formats）：将Y、U、V值存储成Macro Pixels数组，和<a href=\"https://zh.wikipedia.org/wiki/RGB\" target=\"_blank\" rel=\"noopener\">RGB</a>的存放方式类似。</li>\n<li>平面格式（planar formats）：将Y、U、V的三个分量分别存放在不同的矩阵中。</li>\n</ul>\n<h3 id=\"YV12\"><a href=\"#YV12\" class=\"headerlink\" title=\"YV12\"></a>YV12</h3><p>YV12是每个像素都提取Y，在UV提取时，将图像2 x 2的矩阵，每个矩阵提取一个U和一个V。YV12格式和I420格式的不同处在V平面和U平面的位置不同。在YV12格式中，V平面紧跟在Y平面之后，然后才是U平面（即：YVU）；但I420则是相反（即：YUV）。<strong>NV12</strong>与YV12类似，效果一样，YV12中U和V是连续排列的，而在NV12中，U和V就交错排列的。</p>\n<p>排列举例： <strong>2*2图像</strong>YYYYVU； <strong>4＊4图像</strong>YYYYYYYYYYYYYYYYVVVVUUUU。</p>\n<p>ps：以上介绍摘自于维基百科、百度百科。</p>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><h3 id=\"获取RGBA数据\"><a href=\"#获取RGBA数据\" class=\"headerlink\" title=\"获取RGBA数据\"></a>获取RGBA数据</h3><p>在这里主要介绍从Image中获取RGBA数据，会用到CoreGraphics库。</p>\n<p>首先我们需要创建bitmap context</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">CGContextRef</span>) newBitmapRGBA8ContextFromImage:(<span class=\"built_in\">CGImageRef</span>) image &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRef</span> context = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</span><br><span class=\"line\">\tuint32_t *bitmapData;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t bitsPerPixel = <span class=\"number\">32</span>; <span class=\"comment\">//每一个像素 由4个通道构成(RGBA)，每一个通道都是1个byte，4个通道也就是32个bit</span></span><br><span class=\"line\">\tsize_t bitsPerComponent = <span class=\"number\">8</span>; <span class=\"comment\">//可以理解为每个通道的bit数</span></span><br><span class=\"line\">\tsize_t bytesPerPixel = bitsPerPixel / bitsPerComponent; <span class=\"comment\">//每个像素点的byte大小</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t width = <span class=\"built_in\">CGImageGetWidth</span>(image); </span><br><span class=\"line\">\tsize_t height = <span class=\"built_in\">CGImageGetHeight</span>(image);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t bytesPerRow = width * bytesPerPixel; <span class=\"comment\">//每一行的字节数</span></span><br><span class=\"line\">\tsize_t bufferLength = bytesPerRow * height; <span class=\"comment\">//整个buffer的size</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tcolorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>(); <span class=\"comment\">//指定颜色空间为RGB</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!colorSpace) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error allocating color space RGB\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 开辟存储位图的内存</span></span><br><span class=\"line\">\tbitmapData = (uint32_t *)malloc(bufferLength);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!bitmapData) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error allocating memory for bitmap\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建bitmap context</span></span><br><span class=\"line\">\tcontext = <span class=\"built_in\">CGBitmapContextCreate</span>(bitmapData, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\twidth, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\theight, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tbitsPerComponent, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tbytesPerRow, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcolorSpace, </span><br><span class=\"line\">                                    kCGImageAlphaPremultipliedLast);\t<span class=\"comment\">// RGBA</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!context) &#123;</span><br><span class=\"line\">        free(bitmapData);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Bitmap context not created\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> context;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来需要向image绘制到bitmap context，然后从context中获取bitmap data。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *) convertUIImageToBitmapRGBA8:(<span class=\"built_in\">UIImage</span> *) image &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGImageRef</span> imageRef = image.CGImage;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建bitmap context</span></span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRef</span> context = [<span class=\"keyword\">self</span> newBitmapRGBA8ContextFromImage:imageRef];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!context) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t width = <span class=\"built_in\">CGImageGetWidth</span>(imageRef);</span><br><span class=\"line\">\tsize_t height = <span class=\"built_in\">CGImageGetHeight</span>(imageRef);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 将image绘制到bitmap context</span></span><br><span class=\"line\">\t<span class=\"built_in\">CGContextDrawImage</span>(context, rect, imageRef);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 获取bitmap context\t中的数据指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *bitmapData = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)<span class=\"built_in\">CGBitmapContextGetData</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 拷贝 bitmap text中的数据</span></span><br><span class=\"line\">\tsize_t bytesPerRow = <span class=\"built_in\">CGBitmapContextGetBytesPerRow</span>(context);</span><br><span class=\"line\">\tsize_t bufferLength = bytesPerRow * height;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *newBitmap = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bitmapData) &#123;</span><br><span class=\"line\">\t\tnewBitmap = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)malloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>) * bytesPerRow * height);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(newBitmap) &#123;\t<span class=\"comment\">// 拷贝数据</span></span><br><span class=\"line\">\t\t\tmemcpy(newBitmap, bitmapData, bufferLength);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tfree(bitmapData);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error getting bitmap pixel data\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newBitmap;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看了这段代码，你可能会有疑问，为什么不直接返回bitmapData呢？这是因为在我们释放bitmap context后，会释放掉bitmapData，所以这就需要我们从新申请空间将数据拷贝到重新开辟的空间了。</p>\n<h3 id=\"格式化图像数据\"><a href=\"#格式化图像数据\" class=\"headerlink\" title=\"格式化图像数据\"></a>格式化图像数据</h3><p>因为YV12要求以像素的2 * 2矩阵来做转换，所以在做RGB转换YV12之前，我们需要先格式化图像数据，以满足要求。</p>\n<p>首先需要格式化图片size，在这里我们以8来对齐，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (CGSize)fromatImageSizeToYV12Size:(CGSize)originalSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CGSize targetSize = CGSizeMake(originalSize.width, originalSize.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //除以8是为了位对齐</span><br><span class=\"line\">    int widthRemainder = (int)originalSize.width % 8;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (widthRemainder != 0) &#123;</span><br><span class=\"line\">        targetSize.width -= widthRemainder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int heightRemainder = (int)originalSize.height % 8;</span><br><span class=\"line\">    if (heightRemainder != 0) &#123;</span><br><span class=\"line\">        targetSize.height -= heightRemainder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return targetSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上个步骤我们计算得到了满足YV12格式的size，在这里还需要根据计算到的size来格式化image data，以满足YV12格式要求，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)formatImageDataToYV12:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)originalData outputData:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)outputData originalWidth:(<span class=\"built_in\">CGFloat</span>)originalWidth targetSize:(<span class=\"built_in\">CGSize</span>)targetSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> targetHeight = targetSize.height;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> targetWidth = targetSize.width;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *pTemp = outputData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//按照targetSize逐行拷贝数据, 乘以4是因为每个size表示4个通道</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; targetHeight; i++) &#123;</span><br><span class=\"line\">        memcpy(pTemp, originalData, targetWidth * <span class=\"number\">4</span>);</span><br><span class=\"line\">        originalData += (<span class=\"keyword\">int</span>)originalWidth * <span class=\"number\">4</span>;</span><br><span class=\"line\">        pTemp += (<span class=\"keyword\">int</span>)targetWidth * <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数据准备好了，接下来，可以进入真正的主题，RGBA转换为YV12了。</p>\n<h3 id=\"RGBA转YV12\"><a href=\"#RGBA转YV12\" class=\"headerlink\" title=\"RGBA转YV12\"></a>RGBA转YV12</h3><p>对于RGB转换为对应的YV12，转换规则都是大佬们研究出来的，只是实现的方式各有不同，我在这里罗列了我找到的几种方式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> rgb2yuv(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> g, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> *y, <span class=\"keyword\">int</span> *u, <span class=\"keyword\">int</span> *v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1 常规转换标准 - 浮点运算，精度高</span></span><br><span class=\"line\">    *y =  <span class=\"number\">0.29882</span>  * r + <span class=\"number\">0.58681</span>  * g + <span class=\"number\">0.114363</span> * b;</span><br><span class=\"line\">    *u = <span class=\"number\">-0.172485</span> * r - <span class=\"number\">0.338718</span> * g + <span class=\"number\">0.511207</span> * b;</span><br><span class=\"line\">    *v =  <span class=\"number\">0.51155</span>  * r - <span class=\"number\">0.42811</span>  * g - <span class=\"number\">0.08343</span>  * b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2 常规转换标准 通过位移来避免浮点运算，精度低</span></span><br><span class=\"line\">    *y = ( <span class=\"number\">76</span>  * r + <span class=\"number\">150</span> * g + <span class=\"number\">29</span>  * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *u = (<span class=\"number\">-44</span>  * r - <span class=\"number\">87</span>  * g + <span class=\"number\">131</span> * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *v = ( <span class=\"number\">131</span> * r - <span class=\"number\">110</span> * g - <span class=\"number\">21</span>  * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3 常规转换标准 通过位移来避免乘法运算，精度低</span></span><br><span class=\"line\">    *y = ( (r&lt;&lt;<span class=\"number\">6</span>) + (r&lt;&lt;<span class=\"number\">3</span>) + (r&lt;&lt;<span class=\"number\">2</span>) + (g&lt;&lt;<span class=\"number\">7</span>) + (g&lt;&lt;<span class=\"number\">4</span>) + (g&lt;&lt;<span class=\"number\">2</span>) + (g&lt;&lt;<span class=\"number\">1</span>) + (b&lt;&lt;<span class=\"number\">4</span>) + (b&lt;&lt;<span class=\"number\">3</span>) + (b&lt;&lt;<span class=\"number\">2</span>) + b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *u = (-(r&lt;&lt;<span class=\"number\">5</span>) - (r&lt;&lt;<span class=\"number\">3</span>) - (r&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">6</span>) - (g&lt;&lt;<span class=\"number\">4</span>) - (g&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">1</span>) - g + (b&lt;&lt;<span class=\"number\">7</span>) + (b&lt;&lt;<span class=\"number\">1</span>) + b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *v = ((r&lt;&lt;<span class=\"number\">7</span>) + (r&lt;&lt;<span class=\"number\">1</span>) + r - (g&lt;&lt;<span class=\"number\">6</span>) - (g&lt;&lt;<span class=\"number\">5</span>) - (g&lt;&lt;<span class=\"number\">3</span>) - (g&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">1</span>) - (b&lt;&lt;<span class=\"number\">4</span>) - (b&lt;&lt;<span class=\"number\">2</span>) - b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 4 高清电视标准：BT.709 常规方法：浮点运算，精度高</span></span><br><span class=\"line\">    *y =  <span class=\"number\">0.2126</span>  * r + <span class=\"number\">0.7152</span>  * g + <span class=\"number\">0.0722</span>  * b;</span><br><span class=\"line\">    *u = <span class=\"number\">-0.09991</span> * r - <span class=\"number\">0.33609</span> * g + <span class=\"number\">0.436</span>   * b;</span><br><span class=\"line\">    *v =  <span class=\"number\">0.615</span>   * r - <span class=\"number\">0.55861</span> * g - <span class=\"number\">0.05639</span> * b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    *v += <span class=\"number\">128</span>;</span><br><span class=\"line\">    *u += <span class=\"number\">128</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的转换方式都是可行的，当然要提升效率的话，还有查表法什么的，这些有兴趣的可以自行搜索。既然转换规则固定了，那么不考虑效率的前提下，我们需要做的就是如何从rgba数组中按照2 * 2矩阵来获取YUV数据并存储下来了。</p>\n<p>在这里介绍采用紧缩格式存储YV12的数据。为了便于理解，在这里先举个栗子：</p>\n<p>下图中的表示一张图中的像素排列，每个像素都包含RGBA通道，将RGBA转换为YV12需要按照2 * 2的像素矩阵为单位来处理，在图中就是按颜色分块中的像素来获取YUV数据，YV12是每4个像素获取一次U、V分量的数据，每个像素都要获取Y分量。</p>\n<p><img src=\"/images/rgb2yuv.png\" alt></p>\n<p>要看转换后的YUV的样子，这里以2 * 2为例，8 个像素生成的YUV如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YYYY YYYY VV UU</span><br></pre></td></tr></table></figure>\n\n<p>有了上面的知识，就可以直接上代码看看了。在这里我们以数组的方式来存储yuv数据，输入的rgba数据我们设置为int型数组，因为每个像素包含4个通道，每个通道都是一个byte，这样每个像素是4个byte，正好是一个int。需要注意的是，在int数组中，按理说每个int的数据应该是:RGBA，但是在iOS上，由于iOS是小端，所以实际上每个int的内容为ABGR，所以在取数据的时候需要注意，避免弄错顺序。还有需要注意的是，计算出来的UV数据需要避免负数，不然颜色值会有问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> rgbaConvert2YV12(<span class=\"keyword\">int</span> *rgbData, uint8_t *yuv, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> frameSize = width * height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vIndex = frameSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uIndex = frameSize * <span class=\"number\">1.25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> R, G, B, Y, U, V, A;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; height; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; width; i++) &#123;<span class=\"comment\">//RGBA</span></span><br><span class=\"line\">            <span class=\"comment\">//样式为ABGR iOS设备为小端</span></span><br><span class=\"line\">            A = (rgbData[index] &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            B = (rgbData[index] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            G = (rgbData[index] &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            R = rgbData[index] &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//转换</span></span><br><span class=\"line\">            rgb2yuv(R, G, B, &amp;Y, &amp;U, &amp;V);</span><br><span class=\"line\">            <span class=\"comment\">//避免负数</span></span><br><span class=\"line\">            U += <span class=\"number\">128</span>;</span><br><span class=\"line\">            V += <span class=\"number\">128</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Y = RANG_CONTROL(Y, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            U = RANG_CONTROL(U, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            V = RANG_CONTROL(V, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            yuv[yIndex++] = Y;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j % <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//按2 * 2矩阵取</span></span><br><span class=\"line\">                yuv[vIndex++] = V;</span><br><span class=\"line\">                yuv[uIndex++] = U;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"YV12转RGBA\"><a href=\"#YV12转RGBA\" class=\"headerlink\" title=\"YV12转RGBA\"></a>YV12转RGBA</h3><p>首先还是yuv转rgb的方法，这与RGB转YV12是对应的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void yuv2rgb(int y, int u, int v, int *r, int *g, int *b)&#123;</span><br><span class=\"line\">    u -= 128;</span><br><span class=\"line\">    v -= 128;</span><br><span class=\"line\">    // 1 常规转换标准 - 浮点运算，精度高</span><br><span class=\"line\">    *r = y                  + (1.370705 * v);</span><br><span class=\"line\">    *g = y - (0.337633 * u) - (0.698001 * v);</span><br><span class=\"line\">    *b = y + (1.732446 * u);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2 常规转换标准 通过位移来避免浮点运算，精度低</span><br><span class=\"line\">    *r = ((256 * y             + (351 * v))&gt;&gt;8);</span><br><span class=\"line\">    *g = ((256 * y - (86  * u) - (179 * v))&gt;&gt;8);</span><br><span class=\"line\">    *b = ((256 * y + (444 * u))            &gt;&gt;8);</span><br><span class=\"line\">    // 3 常规转换标准 通过位移来避免乘法运算，精度低</span><br><span class=\"line\">    *r = (((y&lt;&lt;8) + (v&lt;&lt;8) + (v&lt;&lt;6) + (v&lt;&lt;4) + (v&lt;&lt;3) + (v&lt;&lt;2) + (v&lt;&lt;1) + v)                   &gt;&gt; 8);</span><br><span class=\"line\">    *g = (((y&lt;&lt;8) - (u&lt;&lt;6) - (u&lt;&lt;4) - (u&lt;&lt;2) - (u&lt;&lt;1) - (v&lt;&lt;7) - (v&lt;&lt;5) - (v&lt;&lt;4) - (v&lt;&lt;1) - v) &gt;&gt; 8);</span><br><span class=\"line\">    *b = (((y&lt;&lt;8) + (u&lt;&lt;8) + (u&lt;&lt;7) + (u&lt;&lt;5) + (u&lt;&lt;4) + (u&lt;&lt;3) + (u&lt;&lt;2))                       &gt;&gt; 8);</span><br><span class=\"line\">    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高</span><br><span class=\"line\">    *r = (y               + 1.28033 * v);</span><br><span class=\"line\">    *g = (y - 0.21482 * u - 0.38059 * v);</span><br><span class=\"line\">    *b = (y + 2.12798 * u);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点来了，将YUV数组恢复为RGBA数组</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> YV12Convert2RGB(uint8_t *yuv, uint8_t *rgb, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> frameSize = width * height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rgbIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uvOffset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vIndex = frameSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uIndex = frameSize * <span class=\"number\">1.25</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> R, G, B, Y, U, V;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; height; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; width; j++) &#123;</span><br><span class=\"line\">            Y = yuv[yIndex++];</span><br><span class=\"line\">            uvOffset = i / <span class=\"number\">2</span> * width / <span class=\"number\">2</span> + j / <span class=\"number\">2</span>;<span class=\"comment\">//按2 * 2矩阵 还原</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            V = yuv[vIndex + uvOffset];</span><br><span class=\"line\">            U = yuv[uIndex + uvOffset];</span><br><span class=\"line\">            </span><br><span class=\"line\">            yuv2rgb(Y, U, V, &amp;R, &amp;G, &amp;B);</span><br><span class=\"line\">            </span><br><span class=\"line\">            R = RANG_CONTROL(R, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            G = RANG_CONTROL(G, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            B = RANG_CONTROL(B, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            rgb[rgbIndex++] = R;</span><br><span class=\"line\">            rgb[rgbIndex++] = G;</span><br><span class=\"line\">            rgb[rgbIndex++] = B;</span><br><span class=\"line\">            rgb[rgbIndex++] = <span class=\"number\">255</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是iOS中RGB与YUV互转的方式了，你可以在<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">这里</a>下载demo</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">三元光模式-维基百科</a></p>\n<p><a href=\"https://baike.baidu.com/item/RGB\" target=\"_blank\" rel=\"noopener\">RGB百度百科</a></p>\n<p><a href=\"https://blog.csdn.net/CAICHAO1234/article/details/79260954\" target=\"_blank\" rel=\"noopener\">IOS rgb yuv 转换</a></p>\n<p><a href=\"http://anddymao.com/2017/12/04/2017-12-4-YUV%E5%92%8CRGB%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8AOpenGL%E6%98%BE%E7%A4%BAYUV%E6%95%B0%E6%8D%AE/\" target=\"_blank\" rel=\"noopener\">YUV和RGB互相转换及OpenGL显示YUV数据</a></p>\n<p><a href=\"https://www.jianshu.com/p/a91502c00fb0\" target=\"_blank\" rel=\"noopener\">YUV颜色编码解析</a></p>\n<p><a href=\"https://www.cnblogs.com/dwdxdy/p/3713990.html\" target=\"_blank\" rel=\"noopener\">YUV与RGB格式转化</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>因为项目中要做画面共享，所以需要学一点图像相关的知识，首当其冲就是RGB转YUV了，因为图像处理压缩这一块是由专业对口的同事做的，所以呢，我这就是写一下自己的理解，如有不对的地方，还望指正，谢谢。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><h2 id=\"知识准备\"><a href=\"#知识准备\" class=\"headerlink\" title=\"知识准备\"></a>知识准备</h2><h3 id=\"RGB\"><a href=\"#RGB\" class=\"headerlink\" title=\"RGB\"></a>RGB</h3><p><strong>三原色光模式</strong>（<strong>RGB color model</strong>），又称<strong>RGB颜色模型</strong>或<strong>红绿蓝颜色模型</strong>，是一种<a href=\"https://zh.wikipedia.org/wiki/加色法\" target=\"_blank\" rel=\"noopener\">加色模型</a>，将<a href=\"https://zh.wikipedia.org/wiki/红\" target=\"_blank\" rel=\"noopener\">红</a>（<strong>R</strong>ed）、<a href=\"https://zh.wikipedia.org/wiki/绿色\" target=\"_blank\" rel=\"noopener\">绿</a>（<strong>G</strong>reen）、<a href=\"https://zh.wikipedia.org/wiki/蓝\" target=\"_blank\" rel=\"noopener\">蓝</a>（<strong>B</strong>lue）三<a href=\"https://zh.wikipedia.org/wiki/原色\" target=\"_blank\" rel=\"noopener\">原色</a>的色光以不同的比例相加，以合成产生各种色彩光。</p>\n<h3 id=\"RGB32\"><a href=\"#RGB32\" class=\"headerlink\" title=\"RGB32\"></a>RGB32</h3><p>RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha<a href=\"https://baike.baidu.com/item/通道\" target=\"_blank\" rel=\"noopener\">通道</a>或者不用。（ARGB32就是带Alpha通道的RGB24。）注意在内存中RGB各分量的排列顺序为：BGRA BGRA BGRA…。通常可以使用RGBQUAD数据结构来操作一个像素，它的定义为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagRGBQUAD</span> &#123;</span></span><br><span class=\"line\">BYTE rgbBlue; <span class=\"comment\">// 蓝色分量</span></span><br><span class=\"line\">BYTE rgbGreen; <span class=\"comment\">// 绿色分量</span></span><br><span class=\"line\">BYTE rgbRed; <span class=\"comment\">// 红色分量</span></span><br><span class=\"line\">BYTE rgbReserved; <span class=\"comment\">// 保留字节（用作Alpha通道或忽略）</span></span><br><span class=\"line\">&#125; RGBQUAD。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"YUV\"><a href=\"#YUV\" class=\"headerlink\" title=\"YUV\"></a>YUV</h3><p><strong>YUV</strong>，是一种<a href=\"https://zh.wikipedia.org/wiki/顏色\" target=\"_blank\" rel=\"noopener\">颜色</a><a href=\"https://zh.wikipedia.org/wiki/編碼\" target=\"_blank\" rel=\"noopener\">编码</a>方法。常使用在各个影像处理组件中。 YUV在对照片或影片编码时，考虑到人类的感知能力，允许降低色度的带宽。</p>\n<p>YUV是编译true-color颜色空间（color space）的种类，Y’UV, YUV, <a href=\"https://zh.wikipedia.org/wiki/YCbCr\" target=\"_blank\" rel=\"noopener\">YCbCr</a>，<a href=\"https://zh.wikipedia.org/wiki/YPbPr\" target=\"_blank\" rel=\"noopener\">YPbPr</a>等专有名词都可以称为YUV，彼此有重叠。“Y”表示<strong>明亮度</strong>（Luminance、Luma），“U”和“V”则是<strong>色度</strong>、<strong>浓度</strong>（Chrominance、Chroma）。</p>\n<p>YUV Formats分成两个格式：</p>\n<ul>\n<li>紧缩格式（packed formats）：将Y、U、V值存储成Macro Pixels数组，和<a href=\"https://zh.wikipedia.org/wiki/RGB\" target=\"_blank\" rel=\"noopener\">RGB</a>的存放方式类似。</li>\n<li>平面格式（planar formats）：将Y、U、V的三个分量分别存放在不同的矩阵中。</li>\n</ul>\n<h3 id=\"YV12\"><a href=\"#YV12\" class=\"headerlink\" title=\"YV12\"></a>YV12</h3><p>YV12是每个像素都提取Y，在UV提取时，将图像2 x 2的矩阵，每个矩阵提取一个U和一个V。YV12格式和I420格式的不同处在V平面和U平面的位置不同。在YV12格式中，V平面紧跟在Y平面之后，然后才是U平面（即：YVU）；但I420则是相反（即：YUV）。<strong>NV12</strong>与YV12类似，效果一样，YV12中U和V是连续排列的，而在NV12中，U和V就交错排列的。</p>\n<p>排列举例： <strong>2*2图像</strong>YYYYVU； <strong>4＊4图像</strong>YYYYYYYYYYYYYYYYVVVVUUUU。</p>\n<p>ps：以上介绍摘自于维基百科、百度百科。</p>\n<h2 id=\"进入正题\"><a href=\"#进入正题\" class=\"headerlink\" title=\"进入正题\"></a>进入正题</h2><h3 id=\"获取RGBA数据\"><a href=\"#获取RGBA数据\" class=\"headerlink\" title=\"获取RGBA数据\"></a>获取RGBA数据</h3><p>在这里主要介绍从Image中获取RGBA数据，会用到CoreGraphics库。</p>\n<p>首先我们需要创建bitmap context</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">CGContextRef</span>) newBitmapRGBA8ContextFromImage:(<span class=\"built_in\">CGImageRef</span>) image &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRef</span> context = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">CGColorSpaceRef</span> colorSpace;</span><br><span class=\"line\">\tuint32_t *bitmapData;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t bitsPerPixel = <span class=\"number\">32</span>; <span class=\"comment\">//每一个像素 由4个通道构成(RGBA)，每一个通道都是1个byte，4个通道也就是32个bit</span></span><br><span class=\"line\">\tsize_t bitsPerComponent = <span class=\"number\">8</span>; <span class=\"comment\">//可以理解为每个通道的bit数</span></span><br><span class=\"line\">\tsize_t bytesPerPixel = bitsPerPixel / bitsPerComponent; <span class=\"comment\">//每个像素点的byte大小</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t width = <span class=\"built_in\">CGImageGetWidth</span>(image); </span><br><span class=\"line\">\tsize_t height = <span class=\"built_in\">CGImageGetHeight</span>(image);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t bytesPerRow = width * bytesPerPixel; <span class=\"comment\">//每一行的字节数</span></span><br><span class=\"line\">\tsize_t bufferLength = bytesPerRow * height; <span class=\"comment\">//整个buffer的size</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tcolorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>(); <span class=\"comment\">//指定颜色空间为RGB</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!colorSpace) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error allocating color space RGB\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 开辟存储位图的内存</span></span><br><span class=\"line\">\tbitmapData = (uint32_t *)malloc(bufferLength);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!bitmapData) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error allocating memory for bitmap\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建bitmap context</span></span><br><span class=\"line\">\tcontext = <span class=\"built_in\">CGBitmapContextCreate</span>(bitmapData, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\twidth, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\theight, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tbitsPerComponent, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tbytesPerRow, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcolorSpace, </span><br><span class=\"line\">                                    kCGImageAlphaPremultipliedLast);\t<span class=\"comment\">// RGBA</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!context) &#123;</span><br><span class=\"line\">        free(bitmapData);</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Bitmap context not created\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> context;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来需要向image绘制到bitmap context，然后从context中获取bitmap data。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *) convertUIImageToBitmapRGBA8:(<span class=\"built_in\">UIImage</span> *) image &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGImageRef</span> imageRef = image.CGImage;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建bitmap context</span></span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRef</span> context = [<span class=\"keyword\">self</span> newBitmapRGBA8ContextFromImage:imageRef];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!context) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsize_t width = <span class=\"built_in\">CGImageGetWidth</span>(imageRef);</span><br><span class=\"line\">\tsize_t height = <span class=\"built_in\">CGImageGetHeight</span>(imageRef);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 将image绘制到bitmap context</span></span><br><span class=\"line\">\t<span class=\"built_in\">CGContextDrawImage</span>(context, rect, imageRef);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 获取bitmap context\t中的数据指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *bitmapData = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)<span class=\"built_in\">CGBitmapContextGetData</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 拷贝 bitmap text中的数据</span></span><br><span class=\"line\">\tsize_t bytesPerRow = <span class=\"built_in\">CGBitmapContextGetBytesPerRow</span>(context);</span><br><span class=\"line\">\tsize_t bufferLength = bytesPerRow * height;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *newBitmap = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bitmapData) &#123;</span><br><span class=\"line\">\t\tnewBitmap = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)malloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>) * bytesPerRow * height);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(newBitmap) &#123;\t<span class=\"comment\">// 拷贝数据</span></span><br><span class=\"line\">\t\t\tmemcpy(newBitmap, bitmapData, bufferLength);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tfree(bitmapData);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Error getting bitmap pixel data\\n\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newBitmap;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看了这段代码，你可能会有疑问，为什么不直接返回bitmapData呢？这是因为在我们释放bitmap context后，会释放掉bitmapData，所以这就需要我们从新申请空间将数据拷贝到重新开辟的空间了。</p>\n<h3 id=\"格式化图像数据\"><a href=\"#格式化图像数据\" class=\"headerlink\" title=\"格式化图像数据\"></a>格式化图像数据</h3><p>因为YV12要求以像素的2 * 2矩阵来做转换，所以在做RGB转换YV12之前，我们需要先格式化图像数据，以满足要求。</p>\n<p>首先需要格式化图片size，在这里我们以8来对齐，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (CGSize)fromatImageSizeToYV12Size:(CGSize)originalSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CGSize targetSize = CGSizeMake(originalSize.width, originalSize.height);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //除以8是为了位对齐</span><br><span class=\"line\">    int widthRemainder = (int)originalSize.width % 8;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (widthRemainder != 0) &#123;</span><br><span class=\"line\">        targetSize.width -= widthRemainder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int heightRemainder = (int)originalSize.height % 8;</span><br><span class=\"line\">    if (heightRemainder != 0) &#123;</span><br><span class=\"line\">        targetSize.height -= heightRemainder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return targetSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上个步骤我们计算得到了满足YV12格式的size，在这里还需要根据计算到的size来格式化image data，以满足YV12格式要求，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)formatImageDataToYV12:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)originalData outputData:(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)outputData originalWidth:(<span class=\"built_in\">CGFloat</span>)originalWidth targetSize:(<span class=\"built_in\">CGSize</span>)targetSize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> targetHeight = targetSize.height;</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> targetWidth = targetSize.width;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *pTemp = outputData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//按照targetSize逐行拷贝数据, 乘以4是因为每个size表示4个通道</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; targetHeight; i++) &#123;</span><br><span class=\"line\">        memcpy(pTemp, originalData, targetWidth * <span class=\"number\">4</span>);</span><br><span class=\"line\">        originalData += (<span class=\"keyword\">int</span>)originalWidth * <span class=\"number\">4</span>;</span><br><span class=\"line\">        pTemp += (<span class=\"keyword\">int</span>)targetWidth * <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数据准备好了，接下来，可以进入真正的主题，RGBA转换为YV12了。</p>\n<h3 id=\"RGBA转YV12\"><a href=\"#RGBA转YV12\" class=\"headerlink\" title=\"RGBA转YV12\"></a>RGBA转YV12</h3><p>对于RGB转换为对应的YV12，转换规则都是大佬们研究出来的，只是实现的方式各有不同，我在这里罗列了我找到的几种方式。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> rgb2yuv(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> g, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> *y, <span class=\"keyword\">int</span> *u, <span class=\"keyword\">int</span> *v)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1 常规转换标准 - 浮点运算，精度高</span></span><br><span class=\"line\">    *y =  <span class=\"number\">0.29882</span>  * r + <span class=\"number\">0.58681</span>  * g + <span class=\"number\">0.114363</span> * b;</span><br><span class=\"line\">    *u = <span class=\"number\">-0.172485</span> * r - <span class=\"number\">0.338718</span> * g + <span class=\"number\">0.511207</span> * b;</span><br><span class=\"line\">    *v =  <span class=\"number\">0.51155</span>  * r - <span class=\"number\">0.42811</span>  * g - <span class=\"number\">0.08343</span>  * b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2 常规转换标准 通过位移来避免浮点运算，精度低</span></span><br><span class=\"line\">    *y = ( <span class=\"number\">76</span>  * r + <span class=\"number\">150</span> * g + <span class=\"number\">29</span>  * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *u = (<span class=\"number\">-44</span>  * r - <span class=\"number\">87</span>  * g + <span class=\"number\">131</span> * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *v = ( <span class=\"number\">131</span> * r - <span class=\"number\">110</span> * g - <span class=\"number\">21</span>  * b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3 常规转换标准 通过位移来避免乘法运算，精度低</span></span><br><span class=\"line\">    *y = ( (r&lt;&lt;<span class=\"number\">6</span>) + (r&lt;&lt;<span class=\"number\">3</span>) + (r&lt;&lt;<span class=\"number\">2</span>) + (g&lt;&lt;<span class=\"number\">7</span>) + (g&lt;&lt;<span class=\"number\">4</span>) + (g&lt;&lt;<span class=\"number\">2</span>) + (g&lt;&lt;<span class=\"number\">1</span>) + (b&lt;&lt;<span class=\"number\">4</span>) + (b&lt;&lt;<span class=\"number\">3</span>) + (b&lt;&lt;<span class=\"number\">2</span>) + b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *u = (-(r&lt;&lt;<span class=\"number\">5</span>) - (r&lt;&lt;<span class=\"number\">3</span>) - (r&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">6</span>) - (g&lt;&lt;<span class=\"number\">4</span>) - (g&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">1</span>) - g + (b&lt;&lt;<span class=\"number\">7</span>) + (b&lt;&lt;<span class=\"number\">1</span>) + b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    *v = ((r&lt;&lt;<span class=\"number\">7</span>) + (r&lt;&lt;<span class=\"number\">1</span>) + r - (g&lt;&lt;<span class=\"number\">6</span>) - (g&lt;&lt;<span class=\"number\">5</span>) - (g&lt;&lt;<span class=\"number\">3</span>) - (g&lt;&lt;<span class=\"number\">2</span>) - (g&lt;&lt;<span class=\"number\">1</span>) - (b&lt;&lt;<span class=\"number\">4</span>) - (b&lt;&lt;<span class=\"number\">2</span>) - b)&gt;&gt;<span class=\"number\">8</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 4 高清电视标准：BT.709 常规方法：浮点运算，精度高</span></span><br><span class=\"line\">    *y =  <span class=\"number\">0.2126</span>  * r + <span class=\"number\">0.7152</span>  * g + <span class=\"number\">0.0722</span>  * b;</span><br><span class=\"line\">    *u = <span class=\"number\">-0.09991</span> * r - <span class=\"number\">0.33609</span> * g + <span class=\"number\">0.436</span>   * b;</span><br><span class=\"line\">    *v =  <span class=\"number\">0.615</span>   * r - <span class=\"number\">0.55861</span> * g - <span class=\"number\">0.05639</span> * b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    *v += <span class=\"number\">128</span>;</span><br><span class=\"line\">    *u += <span class=\"number\">128</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的转换方式都是可行的，当然要提升效率的话，还有查表法什么的，这些有兴趣的可以自行搜索。既然转换规则固定了，那么不考虑效率的前提下，我们需要做的就是如何从rgba数组中按照2 * 2矩阵来获取YUV数据并存储下来了。</p>\n<p>在这里介绍采用紧缩格式存储YV12的数据。为了便于理解，在这里先举个栗子：</p>\n<p>下图中的表示一张图中的像素排列，每个像素都包含RGBA通道，将RGBA转换为YV12需要按照2 * 2的像素矩阵为单位来处理，在图中就是按颜色分块中的像素来获取YUV数据，YV12是每4个像素获取一次U、V分量的数据，每个像素都要获取Y分量。</p>\n<p><img src=\"/images/rgb2yuv.png\" alt></p>\n<p>要看转换后的YUV的样子，这里以2 * 2为例，8 个像素生成的YUV如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YYYY YYYY VV UU</span><br></pre></td></tr></table></figure>\n\n<p>有了上面的知识，就可以直接上代码看看了。在这里我们以数组的方式来存储yuv数据，输入的rgba数据我们设置为int型数组，因为每个像素包含4个通道，每个通道都是一个byte，这样每个像素是4个byte，正好是一个int。需要注意的是，在int数组中，按理说每个int的数据应该是:RGBA，但是在iOS上，由于iOS是小端，所以实际上每个int的内容为ABGR，所以在取数据的时候需要注意，避免弄错顺序。还有需要注意的是，计算出来的UV数据需要避免负数，不然颜色值会有问题。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> rgbaConvert2YV12(<span class=\"keyword\">int</span> *rgbData, uint8_t *yuv, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> frameSize = width * height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vIndex = frameSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uIndex = frameSize * <span class=\"number\">1.25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> R, G, B, Y, U, V, A;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; height; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; width; i++) &#123;<span class=\"comment\">//RGBA</span></span><br><span class=\"line\">            <span class=\"comment\">//样式为ABGR iOS设备为小端</span></span><br><span class=\"line\">            A = (rgbData[index] &gt;&gt; <span class=\"number\">24</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            B = (rgbData[index] &gt;&gt; <span class=\"number\">16</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            G = (rgbData[index] &gt;&gt; <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            R = rgbData[index] &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//转换</span></span><br><span class=\"line\">            rgb2yuv(R, G, B, &amp;Y, &amp;U, &amp;V);</span><br><span class=\"line\">            <span class=\"comment\">//避免负数</span></span><br><span class=\"line\">            U += <span class=\"number\">128</span>;</span><br><span class=\"line\">            V += <span class=\"number\">128</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Y = RANG_CONTROL(Y, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            U = RANG_CONTROL(U, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            V = RANG_CONTROL(V, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            yuv[yIndex++] = Y;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j % <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; i % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//按2 * 2矩阵取</span></span><br><span class=\"line\">                yuv[vIndex++] = V;</span><br><span class=\"line\">                yuv[uIndex++] = U;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"YV12转RGBA\"><a href=\"#YV12转RGBA\" class=\"headerlink\" title=\"YV12转RGBA\"></a>YV12转RGBA</h3><p>首先还是yuv转rgb的方法，这与RGB转YV12是对应的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void yuv2rgb(int y, int u, int v, int *r, int *g, int *b)&#123;</span><br><span class=\"line\">    u -= 128;</span><br><span class=\"line\">    v -= 128;</span><br><span class=\"line\">    // 1 常规转换标准 - 浮点运算，精度高</span><br><span class=\"line\">    *r = y                  + (1.370705 * v);</span><br><span class=\"line\">    *g = y - (0.337633 * u) - (0.698001 * v);</span><br><span class=\"line\">    *b = y + (1.732446 * u);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2 常规转换标准 通过位移来避免浮点运算，精度低</span><br><span class=\"line\">    *r = ((256 * y             + (351 * v))&gt;&gt;8);</span><br><span class=\"line\">    *g = ((256 * y - (86  * u) - (179 * v))&gt;&gt;8);</span><br><span class=\"line\">    *b = ((256 * y + (444 * u))            &gt;&gt;8);</span><br><span class=\"line\">    // 3 常规转换标准 通过位移来避免乘法运算，精度低</span><br><span class=\"line\">    *r = (((y&lt;&lt;8) + (v&lt;&lt;8) + (v&lt;&lt;6) + (v&lt;&lt;4) + (v&lt;&lt;3) + (v&lt;&lt;2) + (v&lt;&lt;1) + v)                   &gt;&gt; 8);</span><br><span class=\"line\">    *g = (((y&lt;&lt;8) - (u&lt;&lt;6) - (u&lt;&lt;4) - (u&lt;&lt;2) - (u&lt;&lt;1) - (v&lt;&lt;7) - (v&lt;&lt;5) - (v&lt;&lt;4) - (v&lt;&lt;1) - v) &gt;&gt; 8);</span><br><span class=\"line\">    *b = (((y&lt;&lt;8) + (u&lt;&lt;8) + (u&lt;&lt;7) + (u&lt;&lt;5) + (u&lt;&lt;4) + (u&lt;&lt;3) + (u&lt;&lt;2))                       &gt;&gt; 8);</span><br><span class=\"line\">    // 4 高清电视标准：BT.709 常规方法：浮点运算，精度高</span><br><span class=\"line\">    *r = (y               + 1.28033 * v);</span><br><span class=\"line\">    *g = (y - 0.21482 * u - 0.38059 * v);</span><br><span class=\"line\">    *b = (y + 2.12798 * u);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点来了，将YUV数组恢复为RGBA数组</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> YV12Convert2RGB(uint8_t *yuv, uint8_t *rgb, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> frameSize = width * height;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rgbIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> yIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uvOffset = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vIndex = frameSize;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uIndex = frameSize * <span class=\"number\">1.25</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> R, G, B, Y, U, V;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; height; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; width; j++) &#123;</span><br><span class=\"line\">            Y = yuv[yIndex++];</span><br><span class=\"line\">            uvOffset = i / <span class=\"number\">2</span> * width / <span class=\"number\">2</span> + j / <span class=\"number\">2</span>;<span class=\"comment\">//按2 * 2矩阵 还原</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            V = yuv[vIndex + uvOffset];</span><br><span class=\"line\">            U = yuv[uIndex + uvOffset];</span><br><span class=\"line\">            </span><br><span class=\"line\">            yuv2rgb(Y, U, V, &amp;R, &amp;G, &amp;B);</span><br><span class=\"line\">            </span><br><span class=\"line\">            R = RANG_CONTROL(R, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            G = RANG_CONTROL(G, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            B = RANG_CONTROL(B, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            rgb[rgbIndex++] = R;</span><br><span class=\"line\">            rgb[rgbIndex++] = G;</span><br><span class=\"line\">            rgb[rgbIndex++] = B;</span><br><span class=\"line\">            rgb[rgbIndex++] = <span class=\"number\">255</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是iOS中RGB与YUV互转的方式了，你可以在<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">这里</a>下载demo</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E5%8E%9F%E8%89%B2%E5%85%89%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">三元光模式-维基百科</a></p>\n<p><a href=\"https://baike.baidu.com/item/RGB\" target=\"_blank\" rel=\"noopener\">RGB百度百科</a></p>\n<p><a href=\"https://blog.csdn.net/CAICHAO1234/article/details/79260954\" target=\"_blank\" rel=\"noopener\">IOS rgb yuv 转换</a></p>\n<p><a href=\"http://anddymao.com/2017/12/04/2017-12-4-YUV%E5%92%8CRGB%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%8F%8AOpenGL%E6%98%BE%E7%A4%BAYUV%E6%95%B0%E6%8D%AE/\" target=\"_blank\" rel=\"noopener\">YUV和RGB互相转换及OpenGL显示YUV数据</a></p>\n<p><a href=\"https://www.jianshu.com/p/a91502c00fb0\" target=\"_blank\" rel=\"noopener\">YUV颜色编码解析</a></p>\n<p><a href=\"https://www.cnblogs.com/dwdxdy/p/3713990.html\" target=\"_blank\" rel=\"noopener\">YUV与RGB格式转化</a></p>\n"},{"title":"initial blog","date":"2019-08-19T15:30:23.000Z","_content":"","source":"_posts/initial-blog.md","raw":"---\ntitle: initial blog\ndate: 2019-08-19 15:30:23\ntags:\ncategories:\n- [Objective-C]\n- [net]\n- [OpenGL]\n- [sundry]\n- [Cocoa]\n- [DesignPattern]\n---\n","slug":"initial-blog","published":1,"updated":"2019-10-23T05:17:06.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyuku000aoqs6g6l2rkax","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql重置密码","date":"2019-09-18T16:18:55.000Z","typora-root-url":"../../source","_content":"\n参考：[mysql 官方重置密码](https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html)\n\n1. 杀掉mysql进程\n\n```shell\n# shell> kill `cat /mysql-data-directory/host_name.pid`\nsudo kill `sudo cat /usr/local/mysql/data/localhost.pid`\n```\n\n2. 重写init.sql\n\n3. ```sql\n   --MySQL 5.7.6 and later:\n   ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass';\n   --MySQL 5.7.5 and earlier:\n   --SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass');\n   ```\n\n   用mysql-init启动mysql\n   \n   ```shell\n   # mysqld --init-file=/initFilePath &\n   shell> sudo mysqld --init-file=/Users/lineworks/Documents/utilities/mysql/mysql-init &\n   ```\n   \n   \n   ","source":"_posts/mysql重置密码.md","raw":"---\ntitle: mysql重置密码\ndate: 2019-09-18 16:18:55\ntags:\ntypora-root-url: ../../source\ncategories:\n- [sundry]\n---\n\n参考：[mysql 官方重置密码](https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html)\n\n1. 杀掉mysql进程\n\n```shell\n# shell> kill `cat /mysql-data-directory/host_name.pid`\nsudo kill `sudo cat /usr/local/mysql/data/localhost.pid`\n```\n\n2. 重写init.sql\n\n3. ```sql\n   --MySQL 5.7.6 and later:\n   ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass';\n   --MySQL 5.7.5 and earlier:\n   --SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass');\n   ```\n\n   用mysql-init启动mysql\n   \n   ```shell\n   # mysqld --init-file=/initFilePath &\n   shell> sudo mysqld --init-file=/Users/lineworks/Documents/utilities/mysql/mysql-init &\n   ```\n   \n   \n   ","slug":"mysql重置密码","published":1,"updated":"2019-10-15T04:00:46.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22tyuky000coqs6bh9gxs7n","content":"<p>参考：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html\" target=\"_blank\" rel=\"noopener\">mysql 官方重置密码</a></p>\n<ol>\n<li>杀掉mysql进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> shell&gt; kill `cat /mysql-data-directory/host_name.pid`</span><br><span class=\"line\">sudo kill `sudo cat /usr/local/mysql/data/localhost.pid`</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>重写init.sql</p>\n</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--MySQL 5.7.6 and later:</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">USER</span> <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'MyNewPass'</span>;</span><br><span class=\"line\"><span class=\"comment\">--MySQL 5.7.5 and earlier:</span></span><br><span class=\"line\"><span class=\"comment\">--SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass');</span></span><br></pre></td></tr></table></figure>\n\n<p>用mysql-init启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> mysqld --init-file=/initFilePath &amp;</span><br><span class=\"line\"><span class=\"meta\">shell&gt;</span> sudo mysqld --init-file=/Users/lineworks/Documents/utilities/mysql/mysql-init &amp;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html\" target=\"_blank\" rel=\"noopener\">mysql 官方重置密码</a></p>\n<ol>\n<li>杀掉mysql进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> shell&gt; kill `cat /mysql-data-directory/host_name.pid`</span><br><span class=\"line\">sudo kill `sudo cat /usr/local/mysql/data/localhost.pid`</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>重写init.sql</p>\n</li>\n<li><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--MySQL 5.7.6 and later:</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">USER</span> <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> <span class=\"keyword\">IDENTIFIED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'MyNewPass'</span>;</span><br><span class=\"line\"><span class=\"comment\">--MySQL 5.7.5 and earlier:</span></span><br><span class=\"line\"><span class=\"comment\">--SET PASSWORD FOR 'root'@'localhost' = PASSWORD('MyNewPass');</span></span><br></pre></td></tr></table></figure>\n\n<p>用mysql-init启动mysql</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> mysqld --init-file=/initFilePath &amp;</span><br><span class=\"line\"><span class=\"meta\">shell&gt;</span> sudo mysqld --init-file=/Users/lineworks/Documents/utilities/mysql/mysql-init &amp;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n"},{"title":"Mac 设置socket5代理","date":"2019-10-23T13:14:18.000Z","typora-root-url":"../../source","_content":"\n# Mac 设置socket5代理\n\nMac端可以在设置->网络->高级->代理中设置http代理与socket代理，但是在这里设置的代理都是http的，并不能直接设置socket的代理。如果想要设置socket的代理的话，需要通过其他的软件来使用。在这里介绍利用==proxifier==来实现socket的代理。\n\n步骤如下：点击proxies，进入proxy列表\n\n<img src=\"/images/proxy_1.png\" width=600pt/>\n\n\n\n点击add进入到添加界面\n\n<img src=\"/images/proxy_3.png\" width=600pt/>\n\n在添加界面输入代理服务器的address与port，并且选择协议类型为http5，点击ok\n\n<img src=\"/images/proxy_2.png\" width=600pt/>\n\n这就设置好socket5的代理了。","source":"_posts/Mac 设置socket5代理.md","raw":"---\ntitle: Mac 设置socket5代理\ndate: 2019-10-23 13:14:18\ntags:\ncategories:\n- [sundry]\ntypora-root-url: ../../source\n---\n\n# Mac 设置socket5代理\n\nMac端可以在设置->网络->高级->代理中设置http代理与socket代理，但是在这里设置的代理都是http的，并不能直接设置socket的代理。如果想要设置socket的代理的话，需要通过其他的软件来使用。在这里介绍利用==proxifier==来实现socket的代理。\n\n步骤如下：点击proxies，进入proxy列表\n\n<img src=\"/images/proxy_1.png\" width=600pt/>\n\n\n\n点击add进入到添加界面\n\n<img src=\"/images/proxy_3.png\" width=600pt/>\n\n在添加界面输入代理服务器的address与port，并且选择协议类型为http5，点击ok\n\n<img src=\"/images/proxy_2.png\" width=600pt/>\n\n这就设置好socket5的代理了。","slug":"Mac 设置socket5代理","published":1,"updated":"2019-10-23T05:52:59.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck22v33b10000ics6zpsi93py","content":"<h1 id=\"Mac-设置socket5代理\"><a href=\"#Mac-设置socket5代理\" class=\"headerlink\" title=\"Mac 设置socket5代理\"></a>Mac 设置socket5代理</h1><p>Mac端可以在设置-&gt;网络-&gt;高级-&gt;代理中设置http代理与socket代理，但是在这里设置的代理都是http的，并不能直接设置socket的代理。如果想要设置socket的代理的话，需要通过其他的软件来使用。在这里介绍利用==proxifier==来实现socket的代理。</p>\n<p>步骤如下：点击proxies，进入proxy列表</p>\n<img src=\"/images/proxy_1.png\" width=\"600pt/\">\n\n\n\n<p>点击add进入到添加界面</p>\n<img src=\"/images/proxy_3.png\" width=\"600pt/\">\n\n<p>在添加界面输入代理服务器的address与port，并且选择协议类型为http5，点击ok</p>\n<img src=\"/images/proxy_2.png\" width=\"600pt/\">\n\n<p>这就设置好socket5的代理了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mac-设置socket5代理\"><a href=\"#Mac-设置socket5代理\" class=\"headerlink\" title=\"Mac 设置socket5代理\"></a>Mac 设置socket5代理</h1><p>Mac端可以在设置-&gt;网络-&gt;高级-&gt;代理中设置http代理与socket代理，但是在这里设置的代理都是http的，并不能直接设置socket的代理。如果想要设置socket的代理的话，需要通过其他的软件来使用。在这里介绍利用==proxifier==来实现socket的代理。</p>\n<p>步骤如下：点击proxies，进入proxy列表</p>\n<img src=\"/images/proxy_1.png\" width=\"600pt/\">\n\n\n\n<p>点击add进入到添加界面</p>\n<img src=\"/images/proxy_3.png\" width=\"600pt/\">\n\n<p>在添加界面输入代理服务器的address与port，并且选择协议类型为http5，点击ok</p>\n<img src=\"/images/proxy_2.png\" width=\"600pt/\">\n\n<p>这就设置好socket5的代理了。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck22tyukc0000oqs6whmeyjro","category_id":"ck22tyukn0005oqs61iuezuri","_id":"ck22tyukz000doqs62kg8yo76"},{"post_id":"ck22tyukt0009oqs67ct0gcd9","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22tyul2000goqs6g673puzv"},{"post_id":"ck22tyuki0002oqs642n9wcnq","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22tyul2000hoqs6cd080pnz"},{"post_id":"ck22tyuky000coqs6bh9gxs7n","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22tyul2000joqs6yt5zac0e"},{"post_id":"ck22tyukm0004oqs6vun1ofpz","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22tyul3000koqs6d4lgb79f"},{"post_id":"ck22tyukp0006oqs6tiyzvhoy","category_id":"ck22tyul1000foqs6w9f7roik","_id":"ck22tyul4000noqs6j92kneu6"},{"post_id":"ck22tyukr0007oqs6u00kk6e3","category_id":"ck22tyul2000ioqs67bpy7k8y","_id":"ck22tyul4000ooqs6y6fx3txe"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyukn0005oqs61iuezuri","_id":"ck22tyul7000roqs6rh0cwccz"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyul2000ioqs67bpy7k8y","_id":"ck22tyul7000soqs6xzt5esb5"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyul1000foqs6w9f7roik","_id":"ck22tyul7000toqs6f9zwlhtw"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22tyul7000uoqs689xewjx3"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyul5000poqs6zv0i6qot","_id":"ck22tyul7000voqs6utskcrdx"},{"post_id":"ck22tyuku000aoqs6g6l2rkax","category_id":"ck22tyul6000qoqs689rylyfb","_id":"ck22tyul8000woqs60d966fvx"},{"post_id":"ck22v33b10000ics6zpsi93py","category_id":"ck22tyuks0008oqs6qok3himu","_id":"ck22v33ba0001ics6gwqi9ah6"}],"PostTag":[],"Tag":[]}}