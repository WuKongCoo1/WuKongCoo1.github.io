---
title: 策略模式
date: 2019-10-28 16:36:30
tags:
categories:
- [DesignPattern]
typora-root-url: ../../source
---
# 策略模式

## 定义：

定义算法族，并分别封装起来，让它们之间可以相互替换，此模式让算法之间的变化独立于使用算法的客户。

## 示例：

假如我们要设计一个游戏系统，其中有角色（Character）、攻击行为（AttackBehavior）。在此游戏中设计三种角色，每一种角色只能同时使用一种武器，但是可以更换武器。接下来让我们进行设计，首先根据之前介绍的设计原则，我们需要先设计一个接口，用来表示攻击行为（AttackBehavior），游戏中的攻击行为都应该实现攻击接口。然后让我们设计Character。由于这个类要使用AttackBehavior来达到攻击效果，所以Charactor需要持有Behavior这个接口，同时提供set方法对behavior进行修改。attack方法通过调用AttackBehavior的attack来实现。三个角色King、master、Warrior分别继承自character。设计后的类图如下：

<img src=/images/StrategyPattern.png width=800pt>

### 代码

**Character.java**

```java
public abstract class Character {
    private AttackBehavior weapon;

    public void setWeapon(AttackBehavior weapon) {
        this.weapon = weapon;
    }

    public void attack() {
        weapon.attack();
    }
}
public class King extends Character {
    @Override
    public void attack() {
        System.out.println("-------King perform attack-------");
        super.attack();
    }
}
public class Master extends Character{
    @Override
    public void attack() {
        System.out.println("-------Master perform attack-------");
        super.attack();
    }
}
public class Warrior extends Character{
    @Override
    public void attack() {
        System.out.println("-------Warrior perform attack-------");
        super.attack();
    }
}
```

**AttackBehavior.java**

```java
public interface AttackBehavior {
    public void attack();
}

public class GunBehavior implements  AttackBehavior
{
    @Override
    public void attack() {
        System.out.println("using gun attack");
    }
}
public class MagicBehavior implements AttackBehavior{
    @Override
    public void attack() {
        System.out.println("using magic attack");
    }
}
public class SwordBehavior implements AttackBehavior{
    @Override
    public void attack() {
        System.out.println("using sword attack");
    }
}
```

Main.java

```java
public class Main {
    public static void main(String[] args) {
        King k = new King();
        k.setWeapon(new SwordBehavior());
        k.attack();

        Master m = new Master();
        m.setWeapon(new MagicBehavior());
        m.attack();

        Warrior w = new Warrior();
        w.setWeapon(new GunBehavior());
        w.attack();

        System.out.println("---King change weapon---");
        k.setWeapon(new MagicBehavior());
        k.attack();
    }
}
```

**运行结果**

<img src="/images/StrategyResult.png">

### 总结

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

**适用**：适用于需要多种算法自由切换的场景